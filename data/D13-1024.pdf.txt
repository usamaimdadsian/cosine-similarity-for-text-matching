Proceedings of the 2013 Conference on Empirical Methods in Natural Language Processing, pages 233–243,
Seattle, Washington, USA, 18-21 October 2013. c©2013 Association for Computational Linguistics
Structured Penalties for Log-linear Language Models
Anil Nelakanti,*‡ Ce´dric Archambeau,* Julien Mairal,† Francis Bach,‡ Guillaume Bouchard*
*Xerox Research Centre Europe, Grenoble, France
†INRIA-LEAR Project-Team, Grenoble, France
‡INRIA-SIERRA Project-Team, Paris, France
firstname.lastname@xrce.xerox.com firstname.lastname@inria.fr
Abstract
Language models can be formalized as log-
linear regression models where the input fea-
tures represent previously observed contexts
up to a certain length m. The complexity
of existing algorithms to learn the parameters
by maximum likelihood scale linearly in nd,
where n is the length of the training corpus
and d is the number of observed features. We
present a model that grows logarithmically
in d, making it possible to efficiently leverage
longer contexts. We account for the sequen-
tial structure of natural language using tree-
structured penalized objectives to avoid over-
fitting and achieve better generalization.
1 Introduction
Language models are crucial parts of advanced nat-
ural language processing pipelines, such as speech
recognition (Burget et al., 2007), machine trans-
lation (Chang and Collins, 2011), or information
retrieval (Vargas et al., 2012). When a sequence
of symbols is observed, a language model pre-
dicts the probability of occurrence of the next sym-
bol in the sequence. Models based on so-called
back-off smoothing have shown good predictive
power (Goodman, 2001). In particular, Kneser-Ney
(KN) and its variants (Kneser and Ney, 1995) are
still achieving state-of-the-art results for more than a
decade after they were originally proposed. Smooth-
ing methods are in fact clever heuristics that require
tuning parameters in an ad-hoc fashion. Hence,
more principled ways of learning language mod-
els have been proposed based on maximum en-
tropy (Chen and Rosenfeld, 2000) or conditional
random fields (Roark et al., 2004), or by adopting
a Bayesian approach (Wood et al., 2009).
In this paper, we focus on penalized maxi-
mum likelihood estimation in log-linear models.
In contrast to language models based on unstruc-
tured norms such as `2 (quadratic penalties) or
`1 (absolute discounting), we use tree-structured
norms (Zhao et al., 2009; Jenatton et al., 2011).
Structured penalties have been successfully applied
to various NLP tasks, including chunking and named
entity recognition (Martins et al., 2011), but not lan-
guage modelling. Such penalties are particularly
well-suited to this problem as they mimic the nested
nature of word contexts. However, existing optimiz-
ing techniques are not scalable for large contexts m.
In this work, we show that structured tree norms
provide an efficient framework for language mod-
elling. For a special case of these tree norms, we
obtain an memory-efficient learning algorithm for
log-linear language models. Furthermore, we aslo
give the first efficient learning algorithm for struc-
tured `? tree norms with a complexity nearly lin-
ear in the number of training samples. This leads to
a memory-efficient and time-efficient learning algo-
rithm for generalized linear language models.
The paper is organized as follows. The model
and other preliminary material is introduced in Sec-
tion 2. In Section 3, we review unstructured penal-
ties that were proposed earlier. Next, we propose
structured penalties and compare their memory and
time requirements. We summarize the characteris-
tics of the proposed algorithms in Section 5 and ex-
perimentally validate our findings in Section 6.
233
34
6
6
5 7
7
7
(a) Trie-structured vector.
w = [ 3 4 6 6 4 5 7 7 ]>.
3
4
6 [2]
4 5
7 [2]
(b) Tree-structured vector.
w = [ 3 4 6 6 4 5 7 7 ]>.
2.8
3.5
4.8
4.3
2.3 3
5.6
4.9
(c) `T2 -proximal ?`T2
(w, 0.8) =
[ 2.8 3.5 4.8 4.3 2.3 3 5.6 4.9 ]>.
3
4
5.2 [2]
3.2 4.2
5.4 [2]
(d) `T?-proximal ?`T? (w, 0.8) =
[ 3 4 5.2 5.2 3.2 4.2 5.4 5.4 ]>.
Figure 1: Example of uncollapsed (trie) and corresponding collapsed (tree) structured vectors and proximal
operators applied to them. Weight values are written inside the node. Subfigure (a) shows the complete
trie S and Subfigure (b) shows the corresponding collapsed tree T . The number in the brackets shows the
number of nodes collapsed. Subfigure (c) shows vector after proximal projection for `T2 -norm (which cannot
be collapsed), and Subfigure (d) that of `T?-norm proximal projection which can be collapsed.
2 Log-linear language models
Multinomial logistic regression and Poisson regres-
sion are examples of log-linear models (McCullagh
and Nelder, 1989), where the likelihood belongs
to an exponential family and the predictor is lin-
ear. The application of log-linear models to lan-
guage modelling was proposed more than a decade
ago (Della Pietra et al., 1997) and it was shown to
be competitive with state-of-the-art language mod-
elling such as Knesser-Ney smoothing (Chen and
Rosenfeld, 2000).
2.1 Model definition
Let V be a set of words or more generally a set of
symbols, which we call vocabulary. Further, let xy
be a sequence of n+1 symbols of V , where x ? V n
and y ? V . We model the probability that symbol y
succeeds x as
P (y = v|x) =
ew
>
v ?m(x)
?
u?V e
w>u ?m(x)
, (1)
where W = {wv}v?V is the set of parameters, and
?m(x) is the vector of features extracted from x, the
sequence preceding y. We will describe the features
shortly.
Let x1:i denote the subsequence of x starting at
the first position up to the ith position and yi the next
symbol in the sequence. Parameters are estimated by
minimizing the penalized log-loss:
W ? ? argmin
W?K
f(W ) + ??(W ), (2)
where f(W ) := ?
?n
i=1 ln p(yi|x1:i;W ) and K is
a convex set representing the constraints applied on
the parameters. Overfitting is avoided by adjust-
ing the regularization parameter ?, e.g., by cross-
validation.
2.2 Suffix tree encoding
Suffix trees provide an efficient way to store and
manipulate discrete sequences and can be con-
structed in linear time when the vocabulary is
fixed (Giegerich and Kurtz, 1997). Recent examples
include language models based on a variable-length
Markovian assumption (Kennington et al., 2012)
and the sequence memoizer (Wood et al., 2011). The
suffix tree data structure encodes all the unique suf-
fixes observed in a sequence up to a maximum given
length. It exploits the fact that the set of observed
contexts is a small subset of all possible contexts.
When a series of suffixes of increasing lengths are
234
Algorithm 1 W ? := argmin {f(X,Y ;W )+
??(W )} Stochastic optimization algorithm (Hu et
al., 2009)
1 Input: ? regularization parameter , L Lipschitz constant of
?f , µ coefficient of strong-convexity of f + ??, X design
matrix, Y label set
2 Initialize: W = Z = 0, ? = ? = 1, ? = L+ µ
3 repeat until maximum iterations
4 #estimate point for gradient update
W = (1? ?)W + ?Z
5 #use mini-batch {X?, Y?} for update
W = ParamUpdate(X?, Y?, W , ?, ?)
6 #weighted combination of estimates
Z = 1??+µ
(
(1? µ)Z + (µ? ?)W + ?W
)
7 #update constants
? = L+ µ/?, ? =
?
4?+?2??
2 , ? = (1? ?)?
Procedure: W := ParamUpdate(X?, Y?, W , ?, ?)
1 W ? = W ? 1??f(X?, Y?,W ) #gradient step
2 W = [W ]+ #projection to non-negative orthant
3 W = ??(w, ?) #proximal step
always observed in the same context, the successive
suffixes are collapsed into a single node. The un-
collapsed version of the suffix tree T is called a suf-
fix trie, which we denote S. A suffix trie also has
a tree structure, but it potentially has much larger
number of nodes. An example of a suffix trie S and
the associated suffix tree T are shown in Figures 1(a)
and 1(b) respectively. We use |S| to denote the num-
ber of nodes in the trie S and |T | for the number of
nodes in the tree T .
Suffix tree encoding is particularly helpful in ap-
plications where the resulting hierarchical structures
are thin and tall with numerous non-branching paths.
In the case of text, it has been observed that the num-
ber of nodes in the tree grows slower than that of
the trie with the length of the sequence (Wood et
al., 2011; Kennington et al., 2012). This is a signif-
icant gain in the memory requirements and, as we
will show in Section 4, can also lead to important
computational gains when this structure is exploited.
The feature vector ?m(x) encodes suffixes (or
contexts) of increasing length up to a maximum
length m. Hence, the model defined in (1) is simi-
lar tom-gram language models. Naively, the feature
vector ?m(x) corresponds to one path of length m
starting at the root of the suffix trie S. The entries
in W correspond to weights for each suffix. We thus
have a trie structure S on W (see Figure 1(a)) con-
straining the number of free parameters. In other
words, there is one weight parameter per node in the
trie S and the matrix of parameters W is of size |S|.
In this work, however, we consider models where
the number of parameters is equal to the size of the
suffix tree T , which has much fewer nodes than S.
This is achieved by ensuring that all parameters cor-
responding to suffixes at a node share the same pa-
rameter value (see Figure 1(b)). These parameters
correspond to paths in the suffix trie that do not
branch i.e. sequence of words that always appear to-
gether in the same order.
2.3 Proximal gradient algorithm
The objective function (2) involves a smooth convex
loss f and a possibly non-smooth penalty ?. Sub-
gradient descent methods for non-smooth ? could
be used, but they are unfortunately very slow to con-
verge. Instead, we choose proximal methods (Nes-
terov, 2007), which have fast convergence rates
and can deal with a large number of penalties ?,
see (Bach et al., 2012).
Proximal methods iteratively update the current
estimate by making a generalized gradient update at
each iteration. Formally, they are based on a lin-
earization of the smooth function f around a param-
eter estimate W , adding a quadratic penalty term
to keep the updated estimate in the neighborhood
of W . At iteration t, the update of the parameter W
is given by
W t+1 = argmin
W?K
{
f(W ) + (W ?W )>?f(W )
+?(W ) +
L
2
?W ?W?22
}
, (3)
where L > 0 is an upper-bound on the Lipschitz
constant of the gradient ?f . The matrix W could
either be the current estimate W t or its weighted
combination with the previous estimate for accel-
erated convergence depending on the specific algo-
rithm used (Beck and Teboulle, 2009). Equation (3)
can be rewritten to be solved in two independent
steps: a gradient update from the smooth part fol-
lowed by a projection depending only on the non-
smooth penalty:
W ? = W ?
1
L
?f(W ), (4)
235
W t+1 = argmin
W?K
1
2
?
?W ?W ?
?
?2
2 +
??(W )
L
. (5)
Update (5) is called the proximal operator of W ?
with parameter ?L that we denote ??
(
W ?, ?L
)
. Ef-
ficiently computing the proximal step is crucial to
maintain the fast convergence rate of these methods.
2.4 Stochastic proximal gradient algorithm
In language modelling applications, the number of
training samples n is typically in the range of 105
or larger. Stochastic version of the proximal meth-
ods (Hu et al., 2009) have been known to be well
adapted when n is large. At every update, the
stochastic algorithm estimates the gradient on a
mini-batch, that is, a subset of the samples. The size
of the mini-batches controls the trade-off between
the variance in the estimate of gradient and the time
required for compute it. In our experiments we use
mini-batches of size 400. The training algorithm is
summarized in Algorithm 1. The acceleration is ob-
tained by making the gradient update at a specific
weighted combination of the current and the previ-
ous estimates of the parameters. The weighting is
shown in step 6 of the Algorithm 1.
2.5 Positivity constraints
Without constraining the parameters, the memory
required by a model scales linearly with the vocabu-
lary size |V |. Any symbol in V observed in a given
context is a positive example, while any symbols
in V that does not appear in this context is a neg-
ative example. When adopting a log-linear language
model, the negative examples are associated with a
small negative gradient step in (4), so that the solu-
tion is not sparse accross multiple categories in gen-
eral. By constraining the parameters to be positive
(i.e., the set of feasible solutions K is the positive
orthant), the projection step 2 in Algorithm 1 can be
done with the same complexity, while maintaining
sparse parameters accross multiple categories. More
precisely, the weights for the category k associated
to a given context x, is always zeros if the category k
never occured after context x. A significant gain in
memory (nearly |V |-fold for large context lengths)
was obtained without loss of accuracy in our exper-
iments.
3 Unstructured penalties
Standard choices for the penalty function ?(W ) in-
clude the `1-norm and the squared `2-norm. The
former typically leads to a solution that is sparse
and easily interpretable, while the latter leads to a
non-sparse, generally more stable one. In partic-
ular, the squared `2 and `1 penalties were used in
the context of log-linear language models (Chen and
Rosenfeld, 2000; Goodman, 2004), reporting perfor-
mances competitive with bi-gram and tri-gram inter-
polated Kneser-Ney smoothing.
3.1 Proximal step on the suffix trie
For squared `2 penalties, the proximal step
?`22(w
t, ?2 ) is the element-wise rescaling operation:
w(t+1)i ? w
(t)
i (1 + ?)
?1 (6)
For `1 penalties, the proximal step ?`1(w
t, ?)] is the
soft-thresholding operator:
w(t+1)i ? max(0, w
(t)
i ? ?). (7)
These projections have linear complexity in the
number of features.
3.2 Proximal step on the suffix tree
When feature values are identical, the corresponding
proximal (and gradient) steps are identical. This can
be seen from the proximal steps (7) and (6), which
apply to single weight entries. This property can be
used to group together parameters for which the fea-
ture values are equal. Hence, we can collapse suc-
cessive nodes that always have the same values in a
suffix trie (as in Figure 1(b)), that is to say we can
directly work on the suffix tree. This leads to a prox-
imal step with complexity that scales linearly with
the number of symbols seen in the corpus (Ukkonen,
1995) and logarithmically with context length.
4 Structured penalties
The `1 and squared `2 penalties do not account for
the sequential dependencies in the data, treating suf-
fixes of different lengths equally. This is inappro-
priate considering that longer suffixes are typically
observed less frequently than shorter ones. More-
over, the fact that suffixes might be nested is disre-
garded. Hence, we propose to use the tree-structured
236
Algorithm 2 w := ?`T2 (w, ?) Proximal projection
step for `T2 on grouping G.
1 Input: T suffix tree, w trie-structured vector, ? threshold
2 Initialize: {?i} = 0, {?i} = 1
3 ? = UpwardPass(?, ?, ?, w)
4 w = DownwardPass(?, w)
Procedure: ? := UpwardPass(?, ?, ?, w)
1 for x ? DepthFirstSuffixTraversal(T, PostOrder)
2 ?x = w2x +
?
h?children(x) ?h
3 ?x = [1? ?/
?
?x]+
4 ?x = ?2x?x
Procedure: w := DownwardPass(?, w)
1 for x ? DepthFirstSuffixTraversal(T, PreOrder)
2 wx = ?xwx
3 for h ? children(x)
4 ?h = ?x?h
a DepthFirstSuffixTraversal(T,Order) returns observed suf-
fixes from the suffix tree T by depth-first traversal in the order
prescribed by Order.
b wx is the weights corresponding to the suffix x from the
weight vector w and children(x) returns all the immediate
children to suffix x in the tree.
norms (Zhao et al., 2009; Jenatton et al., 2011),
which are based on the suffix trie or tree, where sub-
trees correspond to contexts of increasing lengths.
As will be shown in the experiments, this prevents
the model to overfit unlike the `1- or squared `2-
norm.
4.1 Definition of tree-structured `Tp norms
Definition 1. Let x be a training sequence. Group
g(w, j) is the subvector of w associated with the
subtree rooted at the node j of the suffix trie S(x).
Definition 2. Let G denote the ordered set of nodes
of the tree T (x) such that for r < s, g(w, r) ?
g(w, s) = ? or g(w, r) ? g(w, s). The tree-
structured `p-norm is defined as follows:
`Tp (w) =
?
j?G
?g(w, j)?p . (8)
We specifically consider the cases p = 2,? for
which efficient optimization algorithms are avail-
able. The `Tp -norms can be viewed as a group
sparsity-inducing norms, where the groups are or-
ganized in a tree. This means that when the weight
associated with a parent in the tree is driven to zero,
the weights associated to all its descendants should
also be driven to zero.
Algorithm 3 w := ?`T?(w, ?) Proximal projection
step for `T? on grouping G.
Input: T suffix tree, w=[v c] tree-structured vector v with
corresponding number of suffixes collapsed at each node in
c, ? threshold
1 for x ? DepthFirstNodeTraversal(T, PostOrder)
2 g(v, x) := pi`T?( g(v, x), cx? )
Procedure: q := pi`?(q, ?)
Input: q = [v c], qi = [vi ci], i = 1, · · · , |q|
Initialize: U = {}, L = {}, I = {1, · · · , |q|}
1 while I 6= ?
2 pick random ? ? I #choose pivot
3 U = {j|vj ? v?} #larger than v?
4 L = {j|vj < v?} #smaller than v?
5 ?S =
?
i?U vi · ci, ?C =
?
i?U ci
6 if (S + ?S)? (C + ?C)? < ?
7 S := (S + ?S), C := (C + ?C), I := L
8 else I := U\{?}
9 r = S??C , vi := vi ?max(0, vi ? r) #take residuals
a DepthFirstNodeTraversal(T,Order) returns nodes x from the
suffix tree T by depth-first traversal in the order prescribed
by Order.
For structured `Tp -norm, the proximal step
amounts to residuals of recursive projections on the
`q-ball in the order defined by G (Jenatton et al.,
2011), where `q-norm is the dual norm of `p-norm1.
In the case `T2 -norm this comes to a series of pro-
jections on the `2-ball. For `T?-norm it is instead
projections on the `1-ball. The order of projections
defined by G is generated by an upward pass of the
suffix trie. At each node through the upward pass,
the subtree below is projected on the dual norm ball
of size ?, the parameter of proximal step. We detail
the projections on the norm ball below.
4.2 Projections on `q-ball for q = 1, 2
Each of the above projections on the dual norm ball
takes one of the following forms depending on the
choice of the norm. Projection of vector w on the
`2-ball is equivalent to thresholding the magnitude
of w by ? units while retaining its direction:
w ? [||w||2 ? ?]+
w
||w||2
. (9)
This can be performed in time linear in size of w,
O(|w|). Projection of a non-negative vectorw on the
`1-ball is more involved and requires thresholding
1`p-norm and `q-norm are dual to each other if 1p +
1
q = 1.
`2-norm is self-dual while the dual of `?-norm is the `1-norm.
237
by a value such that the entries in the resulting vector
add up to ?, otherwise w remains the same:
w ? [w ? ? ]+ s.t. ||w||1 = ? or ? = 0. (10)
? = 0 is the case where w lies inside the `1-ball
of size ? with ||w||1 < ?, leaving w intact. In the
other case, the threshold ? is to be computed such
that after thresholding, the resulting vector has an
`1-norm of ?. The simplest way to achieve this is
to sort by descending order the entries w = sort(w)
and pick the k largest values such that the (k + 1)th
largest entry is smaller than ? :
k?
i=1
wi ? ? = ? and ? > wk+1. (11)
We refer to wk as the pivot and are only interested in
entries larger than the pivot. Given a sorted vector,
it requires looking up to exactly k entries, however,
sorting itself take O(|w| log |w|).
4.3 Proximal step
Naively employing the projection on the `2-ball de-
scribed above leads to an O(d2) algorithm for `T2
proximal step. This could be improved to a linear al-
gorithm by aggregating all necessary scaling factors
while making an upward pass of the trie S and ap-
plying them in a single downward pass as described
in (Jenatton et al., 2011). In Algorithm 2, we detail
this procedure for trie-structured vectors.
The complexity of `T?-norm proximal step de-
pends directly on that of the pivot finding algorithm
used within its `1-projection method. Naively sort-
ing vectors to find the pivot leads to an O(d2 log d)
algorithm. Pivot finding can be improved by ran-
domly choosing candidates for the pivot and the
best known algorithm due to (Bruckner, 1984) has
amortized linear time complexity in the size of the
vector. This leaves us with O(d2) complexity for
`T?-norm proximal step. (Duchi et al., 2008) pro-
poses a method that scales linearly with the num-
ber of non-zero entries in the gradient update (s)
but logarithmically in d. But recursive calls to
`1-projection over subtrees will fail the sparsity
assumption (with s ? d) making proximal step
quadratic. Procedure for ?`T? on trie-structured vec-
tors using randomized pivoting method is described
in Algorithm 3.
We next explain how the number of `1-projections
can be reduced by switching to the tree T instead of
trie S which is possible due to the good properties of
`T?-norm. Then we present a pivot finding method
that is logarithmic in the feature size for our appli-
cation.
4.4 `T?-norm with suffix trees
We consider the case where all parameters are ini-
tialized with the same value for the optimization pro-
cedure, typically with zeros. The condition that the
parameters at any given node continue to share the
same value requires that both the gradient update (4)
and proximal step (5) have this property. We mod-
ify the tree structure to ensure that after gradient up-
dates parameters at a given node continue to share a
single value. Nodes that do not share a value after
gradient update are split into multiple nodes where
each node has a single value. We formally define
this property as follows:
Definition 3. A constant value non-branching path
is a set of nodes P ? P(T,w) of a tree structure T
w.r.t. vector w if P has |P | nodes with |P |?1 edges
between them and each node has at most one child
and all nodes i, j ? P have the same value in vector
w as wi = wj .
The nodes of Figure 1(b) correspond to constant
value non-branching paths when the values for all
parameters at each of the nodes are the same. Next
we show that this tree structure is retained after
proximal steps of `T?-norm.
Proposition 1. Constant value non-branching paths
P(T,w) of T structured vector w are preserved un-
der the proximal projection step ?`T?(w, ?).
Figure 1(d) illustrates this idea showing `T? pro-
jection applied on the collapsed tree. This makes it
memory efficient but the time required for the prox-
imal step remains the same since we must project
each subtree of S on the `1-ball. The sequence of
projections at nodes of S in a non-branching path
can be rewritten into a single projection step using
the following technique bringing the number of pro-
jections from |S| to |T |.
Proposition 2. Successive projection steps for sub-
trees with root in a constant value non-branching
path P = {g1, · · · , g|P |} ? P(T,w) for ?`T?(w, ?)
238
is pig|P | ?· · ·?pig1(w, ?) applied in bottom-up order
defined by G. The composition of projections can be
rewritten into a single projection step with ? scaled
by the number of projections |P | as,
pig|P |(w, ?|P |) ? pig|P | ? · · · ? pig1(w, ?).
The above propositions show that `T?-norm can be
used with the suffix tree with fewer projection steps.
We now propose a method to further improve each
of these projection steps.
4.5 Fast proximal step for `T?-norm
Let k be the cardinality of the set of values larger
than the pivot in a vector to compute the thresh-
old for `1-projection as referred in (11). This value
varies from one application to another, but for lan-
guage applications, our experiments on 100K en-
glish words (APNews dataset) showed that k is gen-
erally small: its value is on average 2.5, and its
maximum is around 10 and 20, depending on the
regularization level. We propose using a max-heap
data structure (Cormen et al., 1990) to fetch the k-
largest values necessary to compute the threshold.
Given the heap of the entries the cost of finding the
pivot is O(k log(d)) if the pivot is the kth largest en-
try and there are d features. This operation is per-
formed d times for `T?-norm as we traverse the tree
bottom-up. The heap itself is built on the fly dur-
ing this upward pass. At each subtree, the heap is
built by merging those of their children in constant
time by using Fibonacci heaps. This leaves us with a
O(dk log(d)) complexity for the proximal step. This
procedure is detailed in Algorithm 4.
5 Summary of the algorithms
Table 1 summarizes the characteristics of the algo-
rithms associated to the different penalties:
1. The unstructured norms `p do not take into
account the varying sparsity level with con-
text length. For p=1, this leads to a sparse
solution and for p=2, we obtain the classical
quadratic penalty. The suffix tree representa-
tion leads to an efficient memory usage. Fur-
thermore, to make the training algorithm time
efficient, the parameters corresponding to con-
texts which always occur in the same larger
Algorithm 4 w := ?`T?(w, ?) Proximal projection
step for `T? on grouping G using heap data structure.
Input: T suffix tree, w=[v c] tree-structured vector v with
corresponding number of suffixes collapsed at each node in
c, ? threshold
InitializeH = {}# empty set of heaps
1 for x ? DepthFirstNodeTraversal(T, PostOrder)
g(v, x) := pi`T?(w, x, cx?,H )
Procedure: q := pi`?(w, x, ?,H )
1 Hx = NewHeap(vx, cx, vx)
2 for j ? children(x) # merge with child heaps
?x = ?x + ?j # update `1-norm
Hx = Merge(Hx,Hj),H = H\Hj
3 H = H ?Hx, S = 0, C = 0, J = {}
4 ifHx(?) < ?, setHx = 0 return
5 for j ? OrderedIterator(Hx) # get max values
if vj >
S+(vj·cj)??
C+cj
S = S + (vj ·cj), C = C + cj , J = J ? {j}
else break
6 r = S??C , ? = 0 # compute threshold
7 for j ? J # apply threshold
? = min(vj , r), ? = ? + (vj ? ?)
Hj(v) = ?
8 Hx(?) = Hj(?)? ? # update `1-norm
a. Heap structure on vector w holds three values (v, c, ?) at
each node. v, c being value and its count, ? is the `1-norm of
the sub-vector below. Tuples are ordered by decreasing value
of v and Hj refers to heap with values in sub-tree rooted at
j. Merge operation merges the heaps passed. OrderedIterator
returns values from the heap in decreasing order of v.
context are grouped. We will illustrate in the
experiments that these penalties do not lead to
good predictive performances.
2. The `T2 -norm nicely groups features by subtrees
which concurs with the sequential structure of
sequences. This leads to a powerful algorithm
in terms of generalization. But it can only be
applied on the uncollapsed tree since there is
no closure property of the constant value non-
branching path for its proximal step making it
less amenable for larger tree depths.
3. The `T?-norm groups features like the `
T
2 -norm
while additionally encouraging numerous fea-
ture groups to share a single value, leading to
a substantial reduction in memory usage. The
generalization properties of this algorithm is as
good as the generalization obtained with the `T2
penalty, if not better. However, it has the con-
stant value non-branching path property, which
239
Penalty good generalization memory efficient time efficient
unstructured `1 and `22 no yes O(|T |) yes O(|T |)
struct.
`T2 yes no O(|S|) no O(|S|)
`T? rand. pivot yes yes O(|T |) no O(|T |2)
`T? heap yes yes O(|T |) yes O(|T | log |T |)
Table 1: Properties of the algorithms proposed in this paper. Generalization properties are as compared by
their performance with increasing context length. Memory efficiency is measured by the number of free
parameters of W in the optimization. Note that the suffix tree is much smaller than the trie (uncollapsed
tree): |T | << |S|. Time complexities reported are that of one proximal projection step.
2 4 6 8 10 12210220
230240250
260
order of language model
perplexity
 
 KN`22`1`T2`T?
(a) Unweighted penalties.
2 4 6 8 10 12210220
230240250
260
order of language model
perplexity
 
 KNw`22w`1w`T2w`T?
(b) Weighted penalties.
2 4 6 8 10 1202
46
8x 105
order of language model#o
fparame
ters
 
 KNw`T2w`T?
(c) Model complexity for structured
penalties.
Figure 2: (a) compares average perplexity (lower is better) of different methods from 2-gram through 12-
gram on four different 100K-20K train-test splits. (b) plot compares the same with appropriate feature
weighting. (c) compares model complexity for weighted structured penalties w`T2 and w`
T
? measure by
then number of parameters.
means that the proximal step can be applied di-
rectly to the suffix tree. There is thus also a
significant gain of performances.
6 Experiments
In this section, we demonstrate empirically the prop-
erties of the algorithms summarized in Table 1. We
consider four distinct subsets of the Associated Press
News (AP-news) text corpus with train-test sizes of
100K-20K for our experiments. The corpus was
preprocessed as described in (Bengio et al., 2003)
by replacing proper nouns, numbers and rare words
with special symbols “?proper noun?”, “#n” and
“?unknown?” respectively. Punctuation marks are
retained which are treated like other normal words.
Vocabulary size for each of the training subsets was
around 8,500 words. The model was reset at the start
of each sentence, meaning that a word in any given
sentence does not depend on any word in the previ-
ous sentence. The regularization parameter ? is cho-
sen for each model by cross-validation on a smaller
subset of data. Models are fitted to training sequence
of 30K words for different values of ? and validated
against a sequence of 10K words to choose ?.
We quantitatively evaluate the proposed model
using perplexity, which is computed as follows:
P ({xi, yi},W ) = 10
{
?1
nV
?n
i=1 I(yi?V ) log p(yi|x1:i;W )
}
,
where nV =
?
i I(yi ? V ). Performance is mea-
sured for varying depth of the suffix trie with dif-
ferent penalties. Interpolated Kneser-Ney results
were computed using the openly available SRILM
toolkit (Stolcke, 2002).
Figure 2(a) shows perplexity values averaged over
four data subsets as a function of the language model
order. It can be observed that performance of un-
structured `1 and squared `2 penalties improve until
a relatively low order and then degrade, while `T2
penalty does not show such degradation, indicating
240
2 4 6 8 10 1220
4060
tree depth
time(sec)
 
 rand-pivotrand-pivot-col
(a) Iteration time of random-pivoting on
the collapsed and uncollapsed trees.
1 2 3 4 5x 106
2040
60
train size
time(sec
)
 
 k-best heaprand-pivot-col
(b) Iteration time of random-pivoting and
k-best heap on the collapsed tree.
Figure 3: Comparison of different methods for performing `T? proximal projection. The rand-pivot
is the random pivoting method of (Bruckner, 1984) and rand-pivot-col is the same applied with the
nodes collapsed. The k-best heap is the method described in Algorithm 4.
that taking the tree-structure into account is benefi-
cial. Moreover, the log-linear language model with
`T2 penalty performs similar to interpolated Kneser-
Ney. The `T?-norm outperforms all other models
at order 5, but taking the structure into account
does not prevent a degradation of the performance
at higher orders, unlike `T2 . This means that a single
regularization for all model orders is still inappro-
priate.
To investigate this further, we adjust the penal-
ties by choosing an exponential decrease of weights
varying as ?m for a feature at depth m in the suffix
tree. Parameter ? was tuned on a smaller validation
set. The best performing values for these weighted
models w`22, w`1, w`
T
2 and w`
T
? are 0.5, 0.7, 1.1
and 0.85 respectively. The weighting scheme fur-
ther appropriates the regularization at various levels
to suit the problem’s structure. Perplexity plots for
weighted models are shown in Figure 2(b). While
w`1 improves at larger depths, it fails to compare
to others showing that the problem does not admit
sparse solutions. Weighted `22 improves consider-
ably and performs comparably to the unweighted
tree-structured norms. However, the introduction of
weighted features prevents us from using the suf-
fix tree representation, making these models inef-
ficient in terms of memory. Weighted `T? is cor-
rected for overfitting at larger depths and w`T2 gains
more than others. Optimal values for ? are frac-
tional for all norms except w`T2 -norm showing that
the unweighted model `T2 -norm was over-penalizing
features at larger depths, while that of others were
under-penalizing them. Interestingly, perplexity im-
proves up to about 9-grams with w`T2 penalty for
the data set we considered, indicating that there is
more to gain from longer dependencies in natural
language sentences than what is currently believed.
Figure 2(c) compares model complexity mea-
sured by the number of parameters for weighted
models using structured penalties. The `T2 penalty
is applied on trie-structured vectors, which grows
roughly at a linear rate with increasing model order.
This is similar to Kneser-Ney. However, the number
of parameters for the w`T? penalty grows logarith-
mically with the model order. This is due to the fact
that it operates on the suffix tree-structured vectors
instead of the suffix trie-structured vectors. These
results are valid for, both, weighted and unweighted
penalties.
Next, we compare the average time taken per iter-
ation for different implementations of the `T? prox-
imal step. Figure 3(a) shows this time against in-
creasing depth of the language model order for ran-
dom pivoting method with and without the collaps-
ing of parameters at different constant value non-
branching paths. The trend in this plot resembles
that of the number of parameters in Figure 2(c). This
shows that the complexity of the full proximal step
is sublinear when accounting for the suffix tree data
structure. Figure 3(b) plots time per iteration ran-
dom pivoting and k-best heap against the varying
size of training sequence. The two algorithms are
operating directly on the suffix tree. It can be ob-
served that the heap-based method are superior with
241
increasing size of training data.
7 Conclusion
In this paper, we proposed several log-linear lan-
guage models. We showed that with an efficient
data structure and structurally appropriate convex
regularization schemes, they were able to outper-
form standard Kneser-Ney smoothing. We also de-
veloped a proximal projection algorithm for the tree-
structured `T?-norm suitable for large trees.
Further, we showed that these models can be
trained online, that they accurately learn the m-gram
weights and that they are able to better take advan-
tage of long contexts. The time required to run the
optimization is still a concern. It takes 7583 min-
utes on a standard desktop computer for one pass of
the of the complete AP-news dataset with 13 mil-
lion words which is little more than time reported
for (Mnih and Hinton, 2007). The most time con-
suming part is computing the normalization factor
for the log-loss. A hierarchical model in the flavour
of (Mnih and Hinton, 2008) should lead to signifi-
cant improvements to this end. Currently, the com-
putational bottleneck is due to the normalization fac-
tor in (1) as it appears in every gradient step com-
putation. Significant savings would be obtained by
computing it as described in (Wu and Khundanpur,
2000).
Acknowledgements
The authors would like to thank anonymous review-
ers for their comments. This work was partially
supported by the CIFRE grant 1178/2010 from the
French ANRT.
References
F. Bach, R. Jenatton, J. Mairal, and G. Obozinski. 2012.
Optimization with sparsity-inducing penalties. Foun-
dations and Trends in Machine Learning, pages 1–
106.
A. Beck and M. Teboulle. 2009. A fast itera-
tive shrinkage-thresholding algorithm for linear in-
verse problems. SIAM Journal of Imaging Sciences,
2(1):183–202.
Y. Bengio, R. Ducharme, P. Vincent, and C. Jauvin. 2003.
A neural probabilistic language model. Journal of Ma-
chine Learning Research, 3:1137–1155.
P. Bruckner. 1984. An o(n) algorithm for quadratic
knapsack problems. Operations Research Letters,
3:163–166.
L. Burget, P. Matejka, P. Schwarz, O. Glembek, and J.H.
Cernocky. 2007. Analysis of feature extraction and
channel compensation in a GMM speaker recognition
system. IEEE Transactions on Audio, Speech and
Language Processing, 15(7):1979–1986, September.
Y-W. Chang and M. Collins. 2011. Exact decoding
of phrase-based translation models through lagrangian
relaxation. In Proc. Conf. Empirical Methods for Nat-
ural Language Processing, pages 26–37.
S. F. Chen and R. Rosenfeld. 2000. A survey of
smoothing techniques for maximum entropy models.
IEEE Transactions on Speech and Audio Processing,
8(1):37–50.
T. H. Cormen, C. E. Leiserson, and R. L. Rivest. 1990.
An Introduction to Algorithms. MIT Press.
S. Della Pietra, V. Della Pietra, and J. Lafferty. 1997.
Inducing features of random fields. IEEE Transac-
tions on Pattern Analysis and Machine Intelligence,
19(4):380–393.
J. Duchi, S. Shalev-Shwartz, Y. Singer, and T. Chandra.
2008. Efficient projections onto the `1-ball for learn-
ing in high dimensions. Proc. 25th Int. Conf. Machine
Learning.
R. Giegerich and S. Kurtz. 1997. From ukkonen to Mc-
Creight and weiner: A unifying view of linear-time
suffix tree construction. Algorithmica.
J. Goodman. 2001. A bit of progress in language mod-
elling. Computer Speech and Language, pages 403–
434, October.
J. Goodman. 2004. Exponential priors for maximum en-
tropy models. In Proc. North American Chapter of the
Association of Computational Linguistics.
C. Hu, J.T. Kwok, and W. Pan. 2009. Accelerated gra-
dient methods for stochastic optimization and online
learning. Advances in Neural Information Processing
Systems.
R. Jenatton, J. Mairal, G. Obozinski, and F. Bach.
2011. Proximal methods for hierarchical sparse cod-
ing. Journal of Machine Learning Research, 12:2297–
2334.
C. R. Kennington, M. Kay, and A. Friedrich. 2012. Sufx
trees as language models. Language Resources and
Evaluation Conference.
R. Kneser and H. Ney. 1995. Improved backing-off for
m-gram language modeling. In Proc. IEEE Int. Conf.
Acoustics, Speech and Signal Processing, volume 1.
A. F. T. Martins, N. A. Smith, P. M. Q. Aguiar, and
M. A. T. Figueiredo. 2011. Structured sparsity in
structured prediction. In Proc. Conf. Empirical Meth-
ods for Natural Language Processing, pages 1500–
1511.
242
P. McCullagh and J. Nelder. 1989. Generalized linear
models. Chapman and Hall. 2nd edition.
A. Mnih and G. Hinton. 2007. Three new graphical mod-
els for statistical language modelling. Proc. 24th Int.
Conference on Machine Learning.
A. Mnih and G. Hinton. 2008. A scalable hierarchical
distributed language model. Advances in Neural In-
formation Processing Systems.
Y. Nesterov. 2007. Gradient methods for minimizing
composite objective function. CORE Discussion Pa-
per.
B. Roark, M. Saraclar, M. Collins, and M. Johnson.
2004. Discriminative language modeling with con-
ditional random fields and the perceptron algorithm.
Proc. Association for Computation Linguistics.
A. Stolcke. 2002. Srilm- an extensible language mod-
eling toolkit. Proc. Int. Conf. Spoken Language Pro-
cessing, 2:901–904.
E. Ukkonen. 1995. Online construction of suffix trees.
Algorithmica.
S. Vargas, P. Castells, and D. Vallet. 2012. Explicit rel-
evance models in intent-oriented information retrieval
diversification. In Proc. 35th Int. ACM SIGIR Conf.
Research and development in information retrieval,
SIGIR ’12, pages 75–84. ACM.
F. Wood, C. Archambeau, J. Gasthaus, J. Lancelot, and
Y.-W. Teh. 2009. A stochastic memoizer for sequence
data. In Proc. 26th Intl. Conf. on Machine Learning.
F. Wood, J. Gasthaus, C. Archambeau, L. James, and
Y. W. Teh. 2011. The sequence memoizer. In Com-
munications of the ACM, volume 54, pages 91–98.
J. Wu and S. Khundanpur. 2000. Efficient training meth-
ods for maximum entropy language modeling. Proc.
6th Inter. Conf. Spoken Language Technologies, pages
114–117.
P. Zhao, G. Rocha, and B. Yu. 2009. The compos-
ite absolute penalties family for grouped and hierar-
chical variable selection. The Annals of Statistics,
37(6A):3468–3497.
243
