Rigid Grammars in the Associative-Commutative Lambek
Calculus are not Learnable
Christophe Costa Florencio
UiL OTS, Faculty of Arts
Utrecht University
costa@let.uu.n1
Abstract
In (Kanazawa, 1998) it was shown
that rigid Classical Categorial Gram-
mars are learnable (in the sense of
(Gold, 1967)) from strings. Surpris-
ingly there are recent negative results
for, among others, rigid associative
Lamb ek (L) grammars.
In this paper the non-lcarnability
of the class of rigid grammars in
LP (Associative-Commutative Lam-
bek calculus) and LP0 (same, but al-
lowing the empty sequent in deriva-
tions) will be shown.
1 Introduction
The question of learnability of categorial gram-
mar (CG) was first taken up in (Kanazawa,
1998). Categorial grammar is an example of
a radically lexicalized formalism, the details of
which will be discussed in Section 2. Kanazawa
studied only subclasses of Classical Catego-
rial Grammar, results for subclasses of Lam-
bek grammars can be found in (Foret and Nir,
2002a), (Foret and Nir, 2002b).
The model of learnability used here is iden-
tification in the limit from positive data as in-
troduced in (Gold, 1967). 1 In order to show
the non-learnability of rigid LP and LP0 we
'Space restrictions do not allow a full exposition of
this model. The interested reader is referred to the first
two chapters of (Kanazawa, 1998).
construct so-called limit points (to be defined
in Section 3) for these classes.
2 The Lambek Calculus
Categorial grammar originated in (Aj-
dukiewicz, 1935) and was further developed in
(Bar-Hillel, 1953) and (Lambek, 1958). This
paper will only give a brief introduction in
this field, (Casadio, 1988) or (Moortgat, 1997)
offers a more comprehensive overview.
A categorial grammar is a set of assignments
of types to symbols from a fixed alphabet E,
the types are either primitives or are composed
from types with the binary connectives /, \ ,
Rules specify how types are to be combined to
form new types. A string is said to be in the
language generated by grammar G (written as
s e L(C), L is known as a naming function)
if G assigns types to the symbols in the string
such that these types can be combined to de-
rive the distinguished type, normally written as
s or t.
Definition 1 A domain subtype is a subtype
that is in domain position, i.e. for the type
((Al B)IC) the domain subtypes are B and C.
For the type (CVB\A)) the domain subtypes
are C and B.
A range subtype is a subtype that is in range
position, i.e. for the type ((AI B)IC) the range
subtypes are (Al B) and A.
For the type (CVB\A)) the range subtypes are
(B\A) and A. 2
2 Note that product is ignored in this definition.
75
(F. B) I- A	 I' H Al B	 Al- B
	
 [I Ei[11-] 
	 AIB	 (T, A) H A
(B, 1') I- A F H B	 A H B A
	  [\E]
r B \ A	 (F; A) h A
[H A  A I- B 
(F,A)H A. B
A I
- A 
• B	 F[(A, B)] C
  [•E1
[[A] H C
In an application AI B,B H A or B,B\A H
A the type B is an argument and AI B and
B\A are known as functors.
In (Foret and Nir, 2002a) it was shown that
rigid grammars (grammars that assign only
one type to any particular symbol) in L are
not learnable from strings. They made use of
the fact that in L the axiom A/A, A/A —> A/A
(and in Lo the axiom BI(A1A) B) holds.
These axioms cause contraction-like phenom-
ena that allow the existence of limit points
even in a class of rigid grammars. They de-
fined rigid grammars Gn , n C N and G such
that L(an ) = c(b* a*)" and L(G) = e{a, b}*
For G„ the number of alternations between a
sequence of a's and a sequence of b's, (both of
unbounded length) is bounded. This approach
is not readily applicable to either LP or LP0
grammars, since commutativity removes the
bound on the number of alterations in L(a).
Instead we exploit an assymmetry inherent in
the Lifting operation.
As noted in (Lambek, 1988), Lifting is a clo-
sure operation as it enjoys the following prop-
erties (we write AB for both B I(A\B) and
(B A)\B):
A —> AB ,
(AB ) B AB ,
if A C, then AB CB .
Note that in general AB 74 A, which implies
that, during a derivation, once an atomic type
is lifted it cannot be lowered anymore.
The calculus LP was introduced in (van
Benthem, 1986) because of its natural relation
with a fragment of the lambda calculus, but
there is also linguistic motivation for introduc-
ing commutativity. Also see (van Benthem,
1987).
All permutation closures of context-free lan-
guages are recognizable in LP (van Benthem,
1991). Also note that the languages express-
ible in L and NL are precisely the context-
free languages (see (Pentus, 1993; Kandulski,
1988), respectively). These formalisms do not
have the necessary expressive power to capture
natural languages (which require at least mild
context-sensitivity). Therefore more expres-
sive variants have been proposed, for example
A I- A
Figure 1: Sequent-style presentation of the na-
tural deduction rules for NL.
(T,	 H A	 ((r,A),o)H A[com,m,1      [ass](,,,r)H A
	 (r,(a,o))H A
Figure 2: Postulates for LP.
the multi-modal variant (MMCG) where appli-
cability of postulates is controlled through the
use of modal operators in the lexicon. This
variant, without restrictions on postulates, is
a Turing-complete system (Carpenter, 1999).
Recently some restrictions on postulates have
been proposed that restrict expressive power to
(mild) context-sensitivity, see (Moot, 2002).
The presentation of LP used here is due to
(Kurtonina and Moortgat, 1997), it takes NL
(Figure 1) as the 'base logic' 3 and adds asso-
ciativity and commutativity postulates (Figure
2). This facilitates some of the steps in our
(syntactic) proofs, and makes the derivations
more explicit.
3 The construction of a limit point
The following is taken from (Kapur, 1991):
Definition 2 Existence Of A Limit Point
A class G of languages is said to have a limit
point if and only if there exists an infinite se-
quence (L,), EN of languages in G such that
Lo c L i c C C
and there exists another language L in f such
[\11
3 Note that, unless otherwise stated, the empty se-
quent is not allowed, i.e. I— A may not occur in any
derivation. Lambek variants which allow the empty
string have 0 added as subscript, for example NL with
empty sequent is written as NLØ.
76
that
L=
	 Ln*
nEN
The language L is called a limit point of L.
Lemma 3 If L(g) has a limit point, then g is
not (non-effectively) learnable.
In other words, when a class has a limit
point it is not learnable because the input to
the learner can never provide enough informa-
tion to justify convergence. Thus even allow-
ing a non-computable learning function makes
no difference in such a case, and establishing
the existence of a limit point provides a very
strong negative result.
Definition 4 For n = 0, let G, be defined as
E-4 (sla)le
C0 : a 1--> a
C	 c
and for any n e N+, let G, be defined as
? (S/ aa • aa 	0,a)/(a \ 0,a )
n times
? a • a ...a
it times
? a\aa
and let G± be defined as
s	 (sla)I(cle)
G± : a	 a
c	 c/c.
A final word on notation: o - , o- ' , T ... denote
strings, and o-Perm is the function that yields
the set of all permutations of a. 4 Concatena-
tion of strings will be denoted with +, and H
will be taken to mean I—Lp (or HLp 0 , depending
on context).
Lemma 5 The language generated by any Gm ,
n C N, is U{(s, a, 0 2 + 1 )P"in 0 < i < m}.
Proof:
4 We will slightly abuse this notation by letting it
denote any permutation of a, we trust this will not
lead to confusion.
1. It is trivial to show that (s, a, C)Perm C
L(Go).
We prove that for any n e N+,
u{ (s , a, C i+1 ?errn 	0	 <	 i	 <
n} C L(C): Grammar Gm assigns
(s/ aa • aa	 aa)/(a\aa) to s,
	 and
n times
a\aa
 to c. With right-elimination we
get s 0 c H s/ aa • aa a' (and by
71 times
commutation cosH s/ a° • aa. . .aa).
n times
Grammar Gn assigns a • a ... a to a.
n times
Now, the derivation TreeLi f t =
[hypo, H	 [hypo2 H a\ a] 2
hypo, H a I (a\a)
can be combined into derivation
Tr eeLi f tn through it times dot-
introduction to yield hypo, 0... ohypon H
a" • a' a'. Using TreeLiftm as an
n times
argument for right-elimination, with
(s 0 c)Perm H s/ a0 • aa	 aa as functor,
n times
we get (s 0 werm 0 ( ypoi o...ohypon ) H s.
With n times dot-elimination, the last of
which takes a H a•a a as argument,
n, times
the hypotheses 1 through a can be
eliminated, yielding (s 0 c)P"m o a H s.
Using commutation and association we
also get a o (s 0 c)perm H s, etc, so
U{(s, a, c 1 + 1 ?"m = 0} C L(Gn ).
Grammar Gm assigns a \aa to c, so the
derivation TreeCElim =
[hypo H a] l c H a\(a I (a\a)) [\E]
hypo 0 c H al (a\a)
derives the same type as TreeLi ft does.
Since i (0 < i < n) TreeLift deductions
can occur in a derivation for Gm , by re-
placing them with TreeCElim we get i+1
times c in the yield of the complete deduc-
tion.
[\E]hypo, 0 hypo2 H a	 2
77
With application of associativity and
commutativity rules the resulting sequent
can be rearranged so that all hypothe-
ses occur in one minimal subsequent (for
example, s o (((hypo i o c) o hypo 2 ) o
((c o hypo3 ) o c)) H s becomes s
((hypo ' o (hypo 2 o hypo3 )) o (c o (c o
c))) H s), which can then be replaced
through dot-elimination by a. Thus (s o
operm 0 c(i times) oa Hs is obtained,
and any permutation of this as well, by
commutativity and associativity. Thus
U{(s, a, c i + 1 )Perm I, 1 < < n} C L(Gn ),
for any 72 E N+.
Together with the result for L(G0), this
shows that U{(s, a, c i+ 1 )P"m 0 < <
n} C L(Gn ), for any it C N.
2. It is trivial to show that L(Go) C
(s a, c ?erna.,
We prove that for any it e 11+,
L(G,„) g lks, a, C i+l)perm 0 < < n } :
For a string a to be included in a lan-
guage generated by an LP grammar G,
G must assign a type T31 to a symbol
in a that has s as range subtype. For
any G, assigns such a type only to
the symbol s. Furthermore, s occurs
only once, as range subtype, in this
type. Hence s must occur (only) once
in every sentence in L(Gn ). All deriva-
tions for a string in L(G i>i ) will start with
Trec„
	 ass, eara777(SITNVTD,2 	TD2
[1E1
S 0 CT H s IT M
Treeb 
H
	 [/E] (s 0 a) 0 U I— a
	  ss, comm , [.E]
a " 0 s 0 a"' H
where a + a' is some permutation of
o-" ± a" (either a" or a" may be
empty). Since Tri has as domain subtype
TD,2, = aVaa), Tree, must yield aVaa).
This tree can begin with a sequence
of applications of the ass and comm
rules (which only makes sense if a is
not a single symbol), there are some
possibilities after this:
(a) since G„,n > 1 assigns this type to
c, a	 c,
(b) use of [\/1 1 . This implies that the
type a," is derived from the sequent
one step up. This type is a range
type only of TD, out of all types in
Gri>1 . Therefore this derivation can
end in	 hypo o c H 0,a
[hypo H al l c H aVaa) [\E]
which, as far as string language is
concerned, is equivalent to 2a. 5 The
type aa can be interpreted as either
a I (a\a) or (a I a)\a, so more intro-
duction rules can appear. All pos-
sibilities lead to some range subtype
unique to TD 2 (with respect to the
types found in G,), therefore c H
aVaa) must be in Tree,. All the
other types found in this tree must
be introduced by hypotheses, and all
the hypotheses introduced have to
be eliminated within Tree„, and all
these cases are in fact equivalent to
2a.
Since Tri has only one other domain
subtype TM, = a" • a" ...a 	 every
n times
sentence in L(CT ) must contain at least
one symbol to which Gn assigns a type
with a as range subtype, the only symbols
that qualify are a and c. Given that
there are no range subtypes TD,7 to be
found in an , Treeb must be of the form6
Tree,, i
	
Tree,,
7,, iHa
	
7,1-
	  [•I]
Tree'
71 1- a" 	T2 0 . . . 0 Tr HH a: • a" . a" (a — 1 times) [4,1]
H a' • a" . . . a"(il times)
where a' = 'Ti
 +	 Tn. Symbol a is
assigned a • a ... a using hypothetical
73 times
reasoning and applying the Lifting rule it
times this derives TDn , hence it can be
shown that _LI = U-Us, a, c i )Permi = 11
5 Note however that this derivation is not in normal
form as defined in (Tiede, 1998).
6 This is actually a normal form for Treeb, it could
also be left-branching, for example. All the other pos-
sible configurations are equivalent, however, since LP
is associative.
Tree,'
78
[RVTE/ o r0 H al (a\a)
[ H a
is a subset of the language. This case
corresponds with all trees Treel...Treen
being of the form TreeLift where the
hypothesis hypo is cancelled (together
with n — 1 other hypotheses) lower in
the tree by n times application of [•/]
where the last application has argument
a H a•a a.
ti times
Since a" = a/(a \a) (the case a' =
(a/a) \a can be dealt with in similar fash-
ion), any Tree i is either of the form
[ro H a\a] 1
	
 ass, comm, [.E]
H a/(a\a)
which given the type-assignments in Gn>1
can only be a (non-normal form) variant
of TreeLift, or
symbol H al (a\a)
which, given tile type-assignments in
G„>1, is only compatible with the deriva-
tion TreeCElim. Using hypothetical rea-
soning and applying the Right Elimina-
tion rule i < n times, we can obtain i
times the type a". All remaining a's can
be lifted to obtain it
Thus,	 for	 any	 71	 N+,
U{(s, a, 0 i+ 1 )perm
 0 n} C L(Gn ),
and with the result for L(G 0 ),
it follows that for any n E N,
U{(s, a, o < < n} C L(Gri ).
Taken together, 1 and 2 imply that for any
rt E N, L(G) = U{(s, a, c i+ 1 )Perm o< <
n}.
Lemma 6 The language generated by G+ is
a, c+ )perm .
Proof:
1. We show that (s, a, c+)Peim C L(G + ):
Grammar G+ assigns (sla)1(c1c) to s,
and c/c to c. Since in LP the axiom
A/A, A/A —> A/A holds, it follows imme-
diately that co... c H c/c, thus with right-
elimination we get s oc+ H s/a. Grammar
G+ assigns a to a, thus (s oc+)oa H s. By
associativity and commutativity any per-
mutation of this sequent will also derive
s, thus any string in (s, a, c+)P"m can be
derived.
2. We show that L(G+ ) C (s, a, c+)Perm:
For a string a to be included in a lan-
guage generated by an LP grammar G,
G must assign a type T+ to a symbol in
a that has s as subtype. Grammar G+
assigns such a type only to the symbol
s. Furthermore, 8 occurs only once, as
range subtype, in this type. Hence s
must occur (only) once in every sentence
in L(G+ ). Since T+ has only two domain
subtypes TM-p = a and TMF = cic, every
sentence in L(G± ) must contain at least
one symbol to which G+ assigns a type
with a as range subtype, the only symbol
that qualifies is a. Thus all derivations
for a string in this language must start
Tree+
sH (sla)I(elc) a' I- ale
s 	
[1E]
(a') H 8Ia 	 a H a
[1E1
(s 0 (al) 0 a H 8
with  ass, comm,[4•E]a" a s o-" I-
where a' o a is some permutation of
a" +a" (a" and 0-"' may be empty).
Grammar G+
 assigns TDFp as range sub-
types to c, so Tree+ can simply be c H
c/c. Some reflection will show that other
possibilities must be of the (normal) form:
c i H	 [c]i [1E]
c H c
C H C/C 	 C2 0 . . . 0 Ci H C
C . . . C/C 
7111
This shows that there must be one or more c's
in every sentence ill L(G± ). Thus tile language
generated by G+ is (s, a, c+)P"m. 0
C 0 . . . 0 Ci H C
c2 H (lc
	  [1E]
[1E]
79
Theorem 7 The class of rigid LP grammars
has a limit point.
Proof:  From Lemma 5 it follows that the lan-
guages L(Go) C L(Gi) C ... form an infinite
ascending chain.
By Lemma 6 L(G± ) = (s, a, c+)P"m and
for any n E N and 0 < i < n, L(GTh ) —
(s, a, 0 i+ 1 )P', L(G± ) = U,ENL(a„), thus
L(G) is a limit point for the class of rigid
LP grammars.
Corollary 8 The class of rigid LP grammars
is not (non-effectively) learnable from strings.
In contrast to Foret and Le Nir's results, it
is still an open question whether the class of
unidirectional rigid LP grammars is learnable;
the class under consideration is bi-directional,
but only because lifting is necessary for the
construction to work.
Also note that the construction depends on
the presence of introduction and elimination
rules for the product, and cannot be (easily)
adapted for a product-free version of LP.
In the case of LP0, i.e. LP allowing empty
sequents, things are slightly less complicated,
since the axiom BI(AIA) B holds. Con-
sider the following construction:
Definition 9 For any n e N, let G„ be defined
as
? s/ aa • aa 	 a
71 times
	a 
? 	
a • a ... a
n times
? a\aa
and let G. be defined as
• (sla)1(c1c)
C5 : a „ a
• c/c.
Lemma 10 The language generated by any
G„, n c N, is U{(s, a, cz?erm 0 < i < n}.
The proof is very similar to the proof of
Lemma 5.
Lemma 11 The language generated by G. is
(s, a, c Term .
The proof is very similar to the proof of
Lemma 6.
Theorem 12 The class of rigid LP0 gram-
mars has a limit point.
The proof is similar to the proof of Theorem
7; Lemmas 10 and 11 imply the existence of a
limit point.
Corollary 13 The class of rigid L130 gram-
mars is not (non-effectively) learnable from
strings.
This corrolary gives an easy result for mul-
tiplicative intuitionistic linear logic (MILL),
which is an alternative formulation of LP0:
Corollary 14 The class of rigid MILL gram-
mars is not (non-effectively) learnable from
strings.
4 Conclusion
We have shown that the classes of rigid LP
and LP0 grammars have limit points and are
thus not learnable from strings. These results,
as well as the negative results from (Foret and
Nir, 2002a) and (Foret and Nir, 2002b) are
quite surprising in the light of certain gen-
eral results in learnability theory. To quote
(Kanazawa, 1998), page 159:
Placing a numerical bound on the
complexity of a grammar can lead to a
non-trivial learnable class. [...] To-
gether with Shinohara's ((Shinohara,
1990a), (Shinohara, 1990b)) earlier
result [context-free grammars having
at most k rules are learnable], this
suggests that something like this may
in fact turn out to be typical in learn-
ability theory.
The negative results for Lambek-like systems
show that this is not the case. Even placing
bounds on the complexity of the types appear-
ing in the grammar may not help: rigid L is
not even learnable when the order of types is
bounded to 2.
The most important (subclass of) L-variant
for which the question of learnability is still
open is (rigid) NL. Results on the strong gene-
rative capacity of NL can be found in (Tiede,
1999), where it is suggested that they may help
in establishing learnability results.
80
3. (1 ((4 T-1 2), Azo.(zo 71-2 2)))
a•o
s
	
p	 [•4
,)) • ( ,, ,,qd 	(!. / (a \	 •
	(P.2 0 	^ c)) I 5 	,
s	 11) 2 o	 s	 H, 1.a•
' 	 [scspsn]
s 0 ((s, P2). 
[\E]
1)) PI	 a	 [sl 1-, ] s cEs [\E]
A final thought concerns the claim in (Foret
and Nir, 2002a) and (Foret and Nir, 2002b)
that these results demonstrate the paucity of
'fiat' strings as input for a learner. They
suggest that enriched input (i.e. some kind
of bracketing or additional semantic informa-
tion) may overcome this problem, which is
certainly an interesting approach. However,
one could also take another approach to con-
structing learnable classes within some Lam-
bek(like) calculus by restricting the use of pos-
tulates. The multimodal approach (see for ex-
ample (Moortgat and Morrill, 1991)) offers a
way of doing this in the lexicon. The viability
of this approach is of course dependent on the
learnability of the class of rigid NL grammars.
Even given a positive result for this class it
may prove to be very hard to find characteri-
zations of learnable classes of grammars within
the multimodal paradigm.
5 Appendix: Derivations
The following list of derivations was obtained
using Grail 7 , included to give a feel for the kind
of derivations our construction allows.
The list exhaustively enumerates all (normal
form) derivations and corresponding lambda
terms for the string sac given the grammar
G2 and calculus LP0.
H
	  r\EI
I- a 	'
L•11
(1,2 
	  [..E]
1. (1 ((4 7 2 2), Azo.(zo 7 1 2)))
.s, I a] 3	I
s [1)2 H	 .•-• H.:
: •	 •/-11
"
s
 ((ss
	 P2) 
2. (1 (Ayi.(yi 7r 1 2), (4 22)))
'Grail is an automated theorem prover, written by
Richard Moot, designed to aid in the development and
prototyping of grammar fragments for categorial logics.
iro	 a11
 [El
	:s, I cd"	 c I	 E 
	s, 	 c F	 :	 u/,(c/ \ a)
s	 ,/ (a Ra\a)) • (a / 	 ))	 ), •	 (a\a),1
s c •	 o	 p
-	 nmi
s ,p	 s
s c • : 0 P2) 0 ,) ,
 k"'" 1
ss(ascjEs
4. (1 KAyi.(yi '71 2 2), (4 7 1 2)))
References
Kasimir Ajdukiewicz. 1935. Die syntaktische Kon-
nexitdt. Stud. Philos., 1:1 27.
Yehoshua Bar-Hillel. 1953. A quasi-arithmetical
notation for syntactic description. Language,
29:47 58.
Bob Carpenter. 1999. The Turing Completeness
of Multimodal Categorial Grammars. In Jelle
Gerbrandy, Maarten Marx, Maarten de Rijke,
and Yde Venema, editors, JFAK. Essays Dedi-
cated to Johan van Benthem on the Occasion of
his 50th Birthday, Vossiuspers. Amsterdam Uni-
versity Press, Amsterdam.
Claudia Casadio. 1988. Semantic categories and
the development of categorial grammars. In
Oehrle et al. (Oehrle et al., 1988), pages 95-124.
Annie Foret and Yannick Le Nir. 2002a. Lambek
rigid grammars are not learnable from strings.
In Proceedings of the 19th International Con-
ference on Computational Linguistics (COLING
2002), Taipei, Republic of China (Taiwan). Mor-
gan Kaufmann Publishers and ACL.
Annie Foret and Yannick Le Nir. 2002b. On
limit points for some variants of rigid Lambek
grammars. In P. Adriaans, H. Fernau, and
M. van Zaanen, editors, ICGI, volume 2484 of
Lecture Notes in Artificial Intelligence, pages
49-62. Springer-Verlag, September 23-25.
E. Mark Gold. 1967. Language identification in
the limit. Information and Control, 10:447 474.
Makoto Kanazawa. 1998. Learnable Classes of
Categorial Grammars. CSLI Publications, Stan-
ford University, distributed by Cambridge Uni-
versity Press.
•P2 
P2
(.1(d ,) •
s	 s/(.. 	•
81
Maciej Kandulski. 1988. The equivalence of
nonassociative Lambek categorial grammars and
context-free grammars. Zeischrift far Mathema-
tische Logik und Grundlagne der Mathematik,
34:41-52.
Shyam Kapur. 1991. Computational Learning of
Languages. Available as technical report 91-
1234, Department of Computer Science, Cornell
University.
Natasha Kurtonina and Michael Moortgat. 1997.
Structural control. In Patrick Blackburn and
Maarten de Rijke, editors, Specifying syntactic
structures, Studies in Logic, Language and In-
formation. CSLI Publications, Stanford.
Joachim Lambek. 1958. The mathematics of sen-
tence structure. Amer. Math. Monthly, 65:154—
170.
Joachim Lambek. 1988. Categorial and categorical
grammars. In Oehrle et al. (Oehrle et al., 1988),
pages 297-317.
Michael Moortgat and Glyn Morrill. 1991. Heads
and phrases. Type calculus for dependency and
constituent structure. Manuscript.
Michael Moortgat. 1997. Categorial type logics.
In Johan van Benthem and Alice ter Meulen,
editors, Handbook of Logic and Language, pages
93-177. Elsevier Science B.V. Chapter 2.
Richard Moot. 2002. Proof Nets for Linguistic
Analysis. Ph.D. thesis, Utrecht Institute of Lin-
guistics OTS, Utrecht University.
R. T. Oehrle, E. Bach, and D. Wheeler, editors.
1988. Categorial Grammars and Natural Lan-
guage Structures. Reidel, Dordrecht.
Mati Pentus. 1993. Lambek grammars are con-
text free. In Proceedings of the 8th Annual
IEEE Symposium on Logic in Computer Sci-
ence, pages 429-433, Los Alamitos, California.
IEEE Computer Society Press.
Takeshi Shinohara. 1990a. Inductive inference
from positive data is powerful. In The 1990
Workshop on Computational Learning The-
ory, pages 97-101, San Mateo, Calif. Morgan-
Kaufmann.
Takeshi Shinohara. 1990b. Inductive inference of
monotonic formal systems from positive data. In
S. Arikawa, S. Goto, S. Ohsuga, and T. Yoko-
mori, editors, Algorithmic Learning Theory,
pages 339-351. Springer, New York and Berlin.
Hans-JOrg Tiede. 1998. Lambek calculus proofs
and tree automata. In Michael Moortgat, edi-
tor, Logical Aspects of Computational Linguis-
tics Third International Conference, LACL '98,
Selected Papers, volume 2014 of Lecture Notes in
Artificial Intelligence, pages 251-265, Grenoble,
France, December. Springer-Verlag.
Hans-JOrg Tiede. 1999. Deductive Systems and
Grammars: Proofs as Grammatical Structures.
Ph.D. thesis, Illinois Wesleyan University.
Johan van Benthem. 1986. Essays in Logical Se-
mantics. Reidel, Dordrecht.
Johan van Benthem. 1987. Categorial gram-
mar and lambda calculus. In D. Skordev, ed-
itor, Mathematical Logic and Its Applications.
Plenum Press, New York.
Johan van Benthem. 1991. Language in Action:
Categories, Lambdas and Dynamic Logic, vol-
ume 130 of Studies in Logic. North-Holland,
Amsterdam.
82
