Proceedings of the 2011 Conference on Empirical Methods in Natural Language Processing, pages 84–95,
Edinburgh, Scotland, UK, July 27–31, 2011. c©2011 Association for Computational Linguistics
Accurate Parsing with Compact Tree-Substitution Grammars: Double-DOP
Federico Sangati and Willem Zuidema
Institute for Logic, Language and Computation
University of Amsterdam
Science Park 904, 1098 XH Amsterdam, The Netherlands
{f.sangati,zuidema}@uva.nl
Abstract
We present a novel approach to Data-Oriented
Parsing (DOP). Like other DOP models, our
parser utilizes syntactic fragments of arbitrary
size from a treebank to analyze new sentences,
but, crucially, it uses only those which are
encountered at least twice. This criterion al-
lows us to work with a relatively small but
representative set of fragments, which can be
employed as the symbolic backbone of sev-
eral probabilistic generative models. For pars-
ing we define a transform-backtransform ap-
proach that allows us to use standard PCFG
technology, making our results easily replica-
ble. According to standard Parseval metrics,
our best model is on par with many state-of-
the-art parsers, while offering some comple-
mentary benefits: a simple generative proba-
bility model, and an explicit representation of
the larger units of grammar.
1 Introduction
Data-oriented Parsing (DOP) is an approach to
wide-coverage parsing based on assigning structures
to new sentences using fragments of variable size
extracted from a treebank. It was first proposed by
Scha in 1990 and formalized by Bod (1992), and
preceded many developments in statistical parsing
(e.g., the “treebank grammars” of Charniak 1997)
and linguistic theory (e.g., the current popularity
of “constructions”, Jackendoff 2002). A rich lit-
erature on DOP has emerged since, yielding state-
of-the-art results on the Penn treebank benchmark
test (Bod, 2001; Bansal and Klein, 2010) and in-
spiring developments in related frameworks includ-
ing tree kernels (Collins and Duffy, 2002), reranking
(Charniak and Johnson, 2005) and Bayesian adaptor
and fragment grammars (e.g., Johnson et al., 2007;
O’Donnell et al., 2009; Cohn et al., 2010). By for-
malizing the idea of using large fragments of earlier
language experience to analyze new sentences, DOP
captures an important property of language cogni-
tion that has shaped natural language. It therefore
complements approaches that have focused on prop-
erties like lexicalization or incrementality, and might
bring supplementary strengths in other NLP tasks.
Early versions of DOP (e.g., Bod et al., 2003)
aimed at extracting all subtrees of all trees in the
treebank. The total number of constructions, how-
ever, is prohibitively large for non-trivial treebanks:
it grows exponentially with the length of the sen-
tences, yielding the astronomically large number of
approximately 1048 for section 2-21 of the Penn
WSJ corpus. These models thus rely on a big sample
of fragments, which inevitably includes a substan-
tial portion of overspecialized constructions. Later
DOP models have used the Goodman transforma-
tion (Goodman, 1996, 2003) to obtain a compact
representation of all fragments in the treebank (Bod,
2003; Bansal and Klein, 2010). In this case the
grammatical constructions are no longer explicitly
represented, and substantial engineering effort is
needed to optimally tune the models and make them
efficient.
In this paper we present a novel DOP model
(Double-DOP) in which we extract a restricted yet
representative subset of fragments: those recurring
at least twice in the treebank. The explicit represen-
tation of the fragments allows us to derive simple
84
ways of estimating probabilistic models on top of the
symbolic grammar. This and other implementation
choices aim at making the methodology transparent
and easily replicable. The accuracy of Double-DOP
is well within the range of state-of-the-art parsers
currently used in other NLP-tasks, while offering the
additional benefits of a simple generative probability
model and an explicit representation of grammatical
constructions.
The contributions of this paper are summarized as
follows: (i) we describe an efficient tree-kernel algo-
rithm which allows us to extract all recurring frag-
ments, reducing the set of potential elementary units
from the astronomical 1048 to around 106. (ii) We
implement and compare different DOP estimation
techniques to induce a probability model (PTSG)
on top of the extracted symbolic grammar. (iii)
We present a simple transformation of the extracted
fragments into CFG-rules that allows us to use off-
the-shelf PCFG parsing and inference. (iv) We in-
tegrate Double-DOP with recent state-splitting ap-
proaches (Petrov et al., 2006), yielding an even more
accurate parser and a better understanding of the re-
lation between DOP and state-splitting.
The rest of the paper is structured as follows. In
section 2 we describe the symbolic backbone of the
grammar formalism that we will use for parsing.
In section 3 we illustrate the probabilistic exten-
sion of the grammar, including our transformation
of PTSGs to PCFGs that allows us to use a standard
PCFG parser, and a different transform that allows
us to use a standard implementation of the inside-
outside algorithm. In section 4 we present the ex-
perimental setup and the results.
2 The symbolic backbone
The basic idea behind DOP is to allow arbitrarily
large fragments from a treebank to be the elemen-
tary units of production of the grammar. Fragments
can be combined through substitution to obtain the
phrase-structure tree of a new sentence. Figure 1
shows an example of a complete syntactic tree ob-
tained by combining three elementary fragments. As
in previous work, two fragments fi and fj can be
combined (fi ? fj) only if the leftmost substitution
site X? in fi has the same label as the root node of
fj ; in this case the resulting tree will correspond to
fi with fj replacing X . The DOP formalism is dis-
cussed in detail in e.g., Bod et al. (2003).
S
NP? VP
VBD
wore
NP? ?
NP
DT
The
NNP
Free
NNP
French
?
NP
JJ
black
NN
arm
NNS
bands
?
S
NP
DT
The
NNP
Free
NNP
French
VP
VBD
wore
NP
JJ
black
NN
arm
NNS
bands
Figure 1: An example of a derivation of a complete syn-
tactic structure (below) obtained combining three ele-
mentary fragments (above) by means of the substitution
operation ?. Substitution sites are marked with ?.
2.1 Finding Recurring Fragments
The first step to build a DOP model is to define its
symbolic grammar, i.e. the set of elementary frag-
ments in the model. In the current work we explic-
itly extract a subset of fragments from the training
treebank. To limit the fragment set size, we use a
simple but heretofore unexplored constraint: we ex-
tract only those fragments that occur two or more
times in the treebank1. Extracting this particular
set of fragments is not trivial, though: a naive ap-
proach that filters a complete table of fragments to-
gether with their frequencies fails because that set, in
a reasonably sized treebank, is astronomically large.
Instead, we use a dynamic programming algorithm
based on tree-kernel techniques (Collins and Duffy,
2001; Moschitti, 2006; Sangati et al., 2010).
The algorithm iterates over every pair of trees in
1More precisely we extract only the largest shared fragments
for all pairs of trees in the treebank. All subtrees of these ex-
tracted fragments necessarily also occur at least twice, but they
are only explicitly represented in our extracted set if they hap-
pen to form a largest shared fragment from another pair of trees.
Hence, if a large tree occurs twice in the treebank the algorithm
will extract from this pair only the full tree as a fragment and
not all its (exponentially many) subtrees.
85
S
NP
PRP
I
VP
VBP
say
SBAR
S
NP
PRP
they
VP
VBP
are
ADJP
JJ
ready
.
.
S
NP
NNS
Analysts
VP
VBP
say
SBAR
S
NP
NNP
USAir
VP
VBZ
has
NP
JJ
great
NN
promise
.
.
S NP PRP VP VBP SBAR S NP PRP VP VBP ADJP JJ .S × ×NP × ×NNSVP × ×VBP × ×SBAR ×S × ×NP × ×NNPVP ×VBZNPJJ ×NN. ×? ?
Figure 2: Left: example of two trees sharing a single maximum fragment, circled in the two trees. Right: the chart
M which is used in the dynamic algorithm to extract all maximum fragments shared between the two trees. The
highlighted cells in the chart are the ones which contribute to extract the shared fragment. The marked cells are those
for which the corresponding nodes in the two tree have equivalent labels but differ in their lists of child nodes.
the treebank to look for common fragments. Fig-
ure 2 shows an example of a pair of trees ??,?? be-
ing compared. The algorithm builds a chartM with
one column for every indexed non-terminal node ?i
in ?, and one row for every indexed non-terminal
node ?j in ?. Each cellM?i, j? identifies a set of in-
dices corresponding to the largest fragment in com-
mon between the two trees starting from ?i and ?j .
This set is empty if ?i and ?j differ in their labels,
or they don’t have the same list of child nodes. Oth-
erwise (if both the labels and the lists of children
match) the set is computed recursively as follows:
M?i, j? = {?i} ??
? ?
c={1,2,...,|ch(?)|}
M?ch(?i, c), ch(?j , c)?
?
? (1)
where ch(?) returns the indices of ?’s children, and
ch(?, c) the index of its cth child.
After filling the chart, the algorithm extracts the
set of recurring fragments, and stores them in a ta-
ble to keep track of their counts. This is done by
converting back each fragment implicitly defined in
every cell-set2, and filtering out those that are prop-
erly contained in others.
In a second pass over the treebank, exact counts
are obtained for each fragment in the extracted set.
2A cell-set containing a single index corresponds to the frag-
ment including the node with that index together with all its
children.
Parse trees in the training corpus are not necessarily
covered entirely by recurring fragments; to ensure
coverage, we also include in the symbolic backbone
of our Double-DOP model all PCFG-productions
not included in the set of extracted fragments.
2.2 Comparison with previous DOP work
Explicit grammars The number of recurring frag-
ments in our symbolic grammar, extracted from
the training sections of the Penn WSJ treebank3, is
around 1 million, and thus is significantly lower than
previous work extracting explicit fragments (e.g.,
Bod, 2001, used more than 5 million fragments up
to depth 14).
When looking at the extracted fragments we ask
if we could have predicted which fragments occur
twice or more. Figure 3 attempts to tackle this ques-
tion by reporting some statistics on the extracted
fragments. The majority of fragments are rather
small with a limited number of words or substitution
sites in the frontier. Yet, there is a significant por-
tion of fragments, in the tail of the distribution, with
more than 10 words or substitution sites. Since the
space of all fragments with such characteristics is
enormously large, selecting big recurring fragments
using random sampling technique is like finding a
needle in a haystack. Hence, random sampling pro-
cesses (like Bod, 2001), will tend to represent fre-
3This is after the treebank has been preprocessed. See also
section 4.
S
NP
PRP
I
VP
VBP
say
SBAR
S
NP
PRP
they
VP
VBP
are
ADJP
JJ
ready
.
.
S
NP
NNS
Analysts
VP
VBP
say
SBAR
S
NP
NNP
USAir
VP
VBZ
has
NP
JJ
great
NN
promise
.
.
S NP PRP VP VBP SBAR S NP PRP VP VBP ADJP JJ .S × ×NP × ×NNSVP × ×VBP × ×SBAR ×S × ×NP × ×NNPVP ×VBZNPJJ ×NN. ×? ?
Figure 2: Left: example of two trees sharing a single maximum fragment, circled in the two trees. Right: the chart
M which is used in the dynamic algorithm to extract all maximum fragments shared between the two trees. The
highlighted cells in the chart are the ones which contribute to extract the shared fragment. The marked cells are those
for which the corresponding nodes in the two tree have equivalent labels but differ in their lists of child nodes.
the treebank to look for common fragments. Fig-
ure 2 shows an example of a pair of trees ??,?? be-
ing compared. The algorithm builds a chartM with
one column for every indexed non-terminal node ?i
in ?, and one row for every indexed non-terminal
node ?j in ?. Each cellM?i, j? identifies a set of in-
dices corresponding to the largest fragment in com-
mon between the two trees starting from ?i and ?j .
This set is empty if ?i and ?j differ in their labels,
or they don’t have the same list of child nodes. Oth-
erwise (if both the labels and the lists of children
match) the set is computed recursively as follows:
M?i, j? = {?i} ??
? ?
c={1,2,...,|ch(?)|}
M?ch(?i, c), ch(?j , c)?
?
? (1)
where ch(?) returns the indices of ?’s children, and
ch(?, c) the index of its cth child.
After filling the chart, the algorithm extracts the
set of recurring fragments, and stores them in a ta-
ble to keep track of their counts. This is done by
converting back each fragment implicitly defined in
every cell-set2, and filtering out those that are prop-
erly contained in others.
In a second pass over the treebank, exact counts
are obtained for each fragment in the extracted set.
2A cell-set containing a single index corresponds to the frag-
ment including the node with that index together with all its
children.
Parse trees in the training corpus are not necessarily
covered entirely by recurring fragments; to ensure
coverage, we also include in the symbolic backbone
of our Double-DOP model all PCFG-productions
not included in the set of extracted fragments.
2.2 Comparison with previous DOP work
Explicit grammars The number of recurring frag-
ments in our symbolic grammar, extracted from
the training sections of the Penn WSJ treebank3, is
around 1 million, and thus is significantly lower than
previous work extracting explicit fragments (e.g.,
Bod, 2001, used more than 5 million fragments up
to depth 14).
When looking at the extracted fragments we ask
if we could have predicted which fragments occur
twice or more. Figure 3 attempts to tackle this ques-
tion by reporting some statistics on the extracted
fragments. The majority of fragments are rather
small with a limited number of words or substitution
sites in the frontier. Yet, there is a significant por-
tion of fragments, in the tail of the distribution, with
more than 10 words or substitution sites. Since the
space of all fragments with such characteristics is
enormously large, selecting big recurring fragments
using rando sa pling technique is like finding a
needle in a haystack. Hence, rando sa pling pro-
cesses (like Bod, 2001), ill tend to represent fre-
3This is after the treebank has been preprocessed. See also
section 4.
S NP PRP VP VBP SBAR S NP PRP VP VBP ADJP JJ .S × ×NP × ×NNSVP × ×VBP × ×SBAR ×S × ×NP × ×NNPVP ×VBZNPJJ ×NN. ×?
Figure 2: Left: t trees sharing a single maximum fragment, ircled in the two trees. Rig t: t e chart
M which is us i t ic algorithm to extract all maximum fragments shared b tween the two trees. The
highlighted cells in the chart are the ones which contribute to extract the shared fragment. The marked cells are those
for which the corresponding nodes in the two tree have equivalent labels but differ in their lists of child nodes.
the treebank to look for common fragments. Fig-
ure 2 shows an example of a pair of trees ??, ?? be-
i g c mpared. The algorithm builds a chartM with
one column fo every ind xed non-terminal node ?i
in ?, and one row for every ndexed non-terminal
node ?j in ?. Each cellM?i, j? identifies a set of in-
dices corresponding to the l gest agment in com-
mon between the two trees starting from ?i and ?j .
This set is empty if ?i and ?j differ i th ir labels,
or they don’t have the same list of child nodes. Oth-
erwise (if both the labels and the lists of children
match) the set is computed recursively as follows:
M?i, j? = {?i} ??
? ?
c={1,2,...,|ch(?)|}
M?ch(?i, c), ch(?j , c)?
?
? (1)
where ch(?) returns the indices of ?’s children, and
ch(?, c) the index of its c child.
After filling the chart, the algorithm extracts the
set of recurring fragments, and stores them in a ta-
ble to keep track of their counts. This is done by
converting back each fragment implicitly defined in
every cell-set2, and filtering out those that are prop-
erly contained in others.
In a second pass over the treebank, exact counts
are obtained for each fragment in the extracted set.
2A cell-set containing a single index corresponds to the frag-
ment including the node with that index together with all its
children.
Parse trees in the training corpus are not necessarily
covered entirely by recurring fragments; to ensure
c verage, we also include in the symb lic backbone
of o r Double-DOP model all PCFG-productions
not included in the set of extracted fragments.
2.2 Comparison with previous DOP work
Explicit g am ars The numb r of recurring frag-
ments in our symbolic grammar, extracted from
the training sections of the Penn WSJ treebank3, is
around 1 million, and thus is significantly lower than
previous work extracti g explicit fragments (e.g.,
Bod, 2001, used more than 5 million fragments up
to d pth 14).
When looking at th extra ted fragments we ask
if we could have predicted which fragments occur
twice or more. Figure 3 attempts to tackle this ques-
tion by reporting some statistics on the extracted
fragments. The majority of fragments are rather
small with a limited number of words or substitution
sites in the frontier. Yet, there is a significant por-
tion of fragments, in the tail of the distribution, with
more than 10 words or substitution sites. Since the
space of all fragments with such characteristics is
enormously large, selecting big recurring fragments
using random sampling technique is like finding a
needle in a haystack. Hence, random sampling pro-
cesses (like Bod, 2001), will tend to represent fre-
3This is after the treebank has been preprocessed. See also
section 4.
86
quent recurring constructions such as from NP to
NP or whether S or not, together with infrequent
overspecialized fragments like from Houston to NP,
while missing large generic constructions such as
everything you always wanted to know about NP but
were afraid to ask. These large constructions are
excluded completely by models that only allow ele-
mentary trees up to a certain depth (typically 4 or 5)
into the symbolic grammar (Zollmann and Sima’an,
2005; Zuidema, 2007; Borensztajn et al., 2009), or
only elementary trees with exactly one lexical an-
chor (Sangati and Zuidema, 2009).
100101102103104105106  0
 
10
 
20
 
30
 
40
 
50
Number of Fragments
Depth
 / Wo
rds / S
ubstit
ution 
SitesDepth Words
Subst
itutio
n Site
s
Figure 3: Distribution of the recurring fragments types
according to several features: depth, number of words,
and number of substitution sites. Their corresponding
curves peak at 4 (depth), 1 (words), and 4 (substitution
sites).
Implicit grammars Goodman (1996, 2003) de-
fined a transformation for some versions of DOP to
an equivalent PCFG-based model, with the number
of rules extracted from each parse tree linear in the
size of the trees. This transform, representing larger
fragments only implicitly, is used in most recent
DOP parsers (e.g., Bod, 2003; Bansal and Klein,
2010). Bod has promoted the Goodman transform as
the solution to the computational challenges of DOP
(e.g., Bod, 2003); it’s important to realize, how-
ever, that the resulting grammars are still very large:
WSJ sections 2-21 yield about 2.5 million rules in
the basic version of Goodman’s transform. More-
over, the transformed grammars differ from untrans-
formed DOP grammars in that larger fragments are
no longer explicitly represented. Rather, informa-
tion about their frequency is distributed over many
CFG-rules: if a construction occurs n times and con-
tains m context-free productions, Goodman’s trans-
form uses the weights of 7nm +m rules to encode
this fact. Thus, the information that the idiomatic
fragment (PP (IN “out”) (PP (IN “of”) (NP (NN
“town”))))) occurs 3 times in WSJ sections 2-21, is
distributed over 132 rules. This way, an attractive
feature of DOP, viz. the explicit representation of
the ‘productive units’ of language, is lost4.
In addition, grammars that implicitly encode all
fragments found in a treebank are strongly biased to
over-represent big constructions: the great majority
of the entire set of fragments belongs in fact to the
largest tree in the treebank5. DOP models relying on
Goodman’s transform, need therefore to counteract
this tendency. Bansal and Klein (2010), for instance,
rely on a sophisticated tuning technique to correctly
adjust the weights of the rules in the grammar. In
our Double-DOP approach, instead, the number of
fragments extracted from each tree varies much less
(it ranges between 4 and 1,759). This comparison is
shown in figure 4.
3 The probabilistic model
Like CFG grammars, our symbolic model produces
extremely many parse trees for a given test sentence.
We therefore need to disambiguate between the pos-
sible parses by means of a probability model that as-
signs probabilities to fragments, and defines a proper
distribution over the set of possible full parse trees.
For every nonterminal X in the treebank we have:
?
f?FX
p(f) = 1 (2)
where FX is the set of fragments in our sym-
bolic grammar rooted in X . A derivation d =
f1, f2, . . . , fn of t is a sequence of the fragments that
through left-most substitution produces t. The prob-
ability of a derivation is computed as the product of
4Bansal and Klein (2010) address this issue for contigu-
ous constructions by extending the Goodman transform with
a ‘Packed Graph Encoding’ for fragments that “bottom out in
terminals”. However, constructions with variable slots, such as
whether S or not, are left unchanged.
5In fact, the number of extracted fragments increase expo-
nentially with the size of the tree.
87
510102103105101010201050
0
1?104
2?104
3?104
4?104
Number of fragments
Rank
 of tre
e from
 train
 set
Recu
rring 
fragm
ents
All fr
agme
nts
Figure 4: Number of fragments extracted from each tree
in sections 2-21 of the WSJ treebank, when considering
all-fragments (dotted line) and recurring-fragments (solid
line). Trees on the x-axis are ranked according to the
number of fragments. Note the double logarithmic scale
on the y-axis.
the probability of each of its fragments.
P (d) =
?
f?d
p(f) (3)
In section 3.2 we describe ways of obtaining dif-
ferent probability distributions over the fragments in
our grammar. In the following section we assume a
given probabilistic model, and illustrate how to use
standard PCFG parsing.
3.1 Parsing
It is possible to define a simple transform of our
probabilistic fragment grammar, such that off-the-
shelf parsers can be used. In order to perform
the PTSG/PCFG conversion, every fragment in our
grammar must be mapped to a CFG rule which will
keep the same probability as the original fragment.
The corresponding rule will have as the left hand
side the root of the fragment and as the right hand
side its yield, i.e., a sequence of terminals and non-
terminals (substitution sites).
It might occur that several fragments are mapped
to the same CFG rule6. These are interesting cases
of syntactic ambiguity as shown in figure 5. In order
to resolve this problem we need to map each am-
biguous fragment to two unique CFG rules chained
6In our binarized treebank we have 31,465 fragments types
that are ambiguous in this sense.
by a unique artificial node, as shown at the bottom
of the same figure. To the first CFG rule in the chain
we assign the probability of the fragment, while the
second will receive probability 1, so the product
gives back the original probability. The ambiguous
and unambiguous PTSG/PCFG mappings need to be
stored in a table, in order to convert back the com-
pressed CFG derivations to the original PTSG model
after parsing.
Such a transformed PCFG will generate the same
derivations as the original PTSG grammar with iden-
tical probabilities. In our experiment we use a stan-
dard PCFG parser to produce a list of k-best Viterbi
derivations. These, in turn, will be used to maximize
possible objectives as described in section 3.3.
VP
VBD NP
NP
DT NN
PP
IN
“with”
NP
VP
VBD NP
DT NN
PP
IN
“with”
NP
m m
VP
NODE@7276
VP
NODE@7277
NODE@7276
VBD DT NN “with” NP
NODE@7277
VBD DT NN “with” NP
Figure 5: Above: example of 2 ambiguous fragments
mapping to the same CFG rule VP ? VBD DT NN
“with” NP. The first fragment occurs 5 times in the train-
ing treebank, (e.g. in the sentence was an executive with
a manufacturing concern) while the second fragment oc-
curs 4 times (e.g. in the sentence began this campaign
with such high hopes). Below: the two pairs of CFG rules
that are used to map the two fragments to separate CFG
derivations.
3.2 Inducing probability distributions
Relative Frequency Estimate (RFE) The sim-
plest way to assign probabilities to fragments is to
make them proportional to their counts7 in the train-
ing set. When enforcing equation 2, that gives the
7We refer to the counts of each fragment as returned by our
extraction algorithm in section 2.1.
88
Relative Frequency Estimate (RFE):
pRFE(f) =
count(f)?
f ??Froot(f) count(f ?)
(4)
Unlike RFE for PCFGs, however, the RFE for
PTSGs has no clear probabilistic interpretation. In
particular, it does not yield the maximum likelihood
solution, and when used as an estimator for an all-
fragments grammar, it is strongly biased since it as-
signs the great majority of the probability mass to
big fragments (Johnson, 2002). As illustrated in fig-
ure 4 this bias is much weaker when restricting the
set of fragments with our approach. Although this
does not solve all theoretical issues, it makes RFE a
reasonable first choice again.
Equal Weights Estimate (EWE) Various other
ways of choosing the weights of a DOP grammar
have been worked out. The best empirical results
have been reported by Bod (2003) with the EWE
proposed by Goodman (2003). Goodman defined it
for grammars in the Goodman transform, but for ex-
plicit grammars it becomes:
wEWE(f) =
?
t?TB
count(f, t)
|{f ? ? t}| (5)
pEWE(f) =
wEWE(f)?
f ??Froot(f) wEWE(f ?)
(6)
where the first sum is over all parse trees t in the tree-
bank (TB), count(f, t) gives the number of times
fragment f occurs in t, and |{f ? ? t}| is the total
number of subtrees of t that were included in the
symbolic grammar.
Maximum Likelihood (ML) For reestimation,
we can aim at maximizing the likelihood (ML) of
the treebank. For this, it turns out that we can de-
fine another transformation of our PTSG, such that
we can apply standard Inside-Outside algorithm for
PCFGs (Lari and Young, 1990). The original ver-
sion of IO is defined over string rewriting PCFGs,
and maximizes the likelihood of the training set con-
sisting of plain sentences. Reestimation shifts prob-
ability mass between alternative parse trees for a
sentence. In contrast, our grammars consist of frag-
ments of various size, and our training set consists
of parse trees. Reestimation here shifts probability
mass between alternative derivations for a parse tree.
Our transformation approach is illustrated with an
example in figure 6. In step (b) the fragments in
the grammar as well as the original parse trees in
the treebank are “flattened” into bracket notation. In
step (c) each fragment is transformed into a CFG
rule in the transformed meta-grammar, whose right-
hand side is constituted by the bracket notation of
the fragment. Each substitution site X? is raised to
a meta-nonterminal X ?, and all other symbols, in-
cluding parentheses, become meta-terminals. The
left-hand side of the rule is constituted by the origi-
nal root symbol R of the fragment raised to a meta-
nonterminal R?.
The resulting PCFG generates trees in bracket no-
tation, and we can run an of-the-shelf inside-outside
algorithm by presenting it parse trees from the train
corpus in bracket notation8. In the experiments that
we report below we used the RFE from section 3, to
generate the initial weights for the grammar.
(a)
S
A? B
y
?
A
x =
S
A
x
B
y
(b) ( S A? ( B y ) ) ? ( A x ) = ( S ( A x ) ( B y ) )
(c) S’? ( S A’ ( B y ) ) ? A’? ( A x ) =
S’
( S A’
( A x )
( B y ) )
(d) ( S ( A x ) ( B y ) )
Figure 6: Rule and tree transforms that turn PTSG rees-
timation into PCFG reestimation; (a) a derivation of the
sentence x y through successive substitutions of elemen-
tary trees from a PTSG; (b) the same elementary trees
and resulting parse tree in bracket notation; (c) an equiva-
lent derivation with the meta-grammar, where the original
substitution sites reappear as meta-nonterminals (marked
with a prime) and all other symbols as meta-terminals;
(d) the yield of the derivation in c.
8However, the results with inside-outside reported in this pa-
per were obtained with an earlier version of our code that uses
an equivalent but special-purpose implementation.
89
3.3 Maximizing Objectives
MPD The easiest objective in parsing, is to se-
lect the most probable derivation (MPD), obtained
by maximizing equation 3.
MPP A DOP grammar can often generate the
same parse tree t through different derivations
D(t) = d1, d2, . . . dm. The probability of t is there-
fore obtained by summing the probabilities of all its
possible derivations.
P (t) =
?
d?D(t)
p(d) =
?
d?D(t)
?
f?d
p(f) (7)
An intuitive objective for a parser is to select, for
a given sentence, the parse tree with highest proba-
bility according to equation 7, i.e., the most probable
parse (MPP): unfortunately, identifying the MPP is
computationally intractable (Sima’an, 1996). How-
ever, we can approximate the MPP by deriving a list
of k-best derivations, summing up the probabilities
of those resulting in the same parse tree, and select
the tree with maximum probability.
MCP, MRS Following Goodman (1998), Sima’an
(1999, 2003), and others, we also consider other
objectives, in particular, the max constituent parse
(MCP), and the max rule sum (MRS).
MCP maximizes a weighted average of the ex-
pected labeled recall L/NC and (approximated) la-
beled precision L/NG under the given posterior dis-
tribution, where L is the number of correctly labeled
constituents, NC the number of constituents in the
correct tree, and NG the number of constituents in
the guessed tree. Recall is easy to maximize since
the estimated NC is constant. L/NC can be in fact
maximized in:
tˆ = argmax
t
?
lc?t
P (lc) (8)
where lc ranges over all labeled constituents in t
and P (lc) is the marginalized probability of all the
derivation trees in the grammar yielding the sentence
under consideration which contains lc.
Precision, instead, is harder because the denom-
inator NG depends on the chosen guessed tree.
Goodman (1998) proposes to look at another metric
which is strongly correlated with precision, which is
the mistake rate (NG?L)/NC that we want to min-
imize. We combine recall with mistake rate through
linear interpolation:
tˆ = argmax
t
E( LNC
? ?NG ? LNC
) (9)
= argmax
t
?
lc?t
P (lc)? ?(1? P (lc)) (10)
where 10 is obtained from 9 assuming NC constant,
and the optimal level for ? has to be evaluated em-
pirically.
Unlike MPP, the MCP can be calculated effi-
ciently using dynamic programming techniques over
the parse forest. However, in line with the aims of
this paper to produce an easily reproducible imple-
mentation of DOP, we developed an accurate ap-
proximation of the MCP using a list of k-best deriva-
tions, such as those that can be obtained with an off-
the-shelf PCFG parser.
We do so by building a standard CYK chart,
where every cell corresponds to a specific span in
the test sentence. We store in each cell the proba-
bility of seeing every label in the grammar yielding
the corresponding span, by marginalizing the prob-
abilities of all the parse trees in the obtained k-best
derivations that contains that label covering the same
span. We then compute the Viterbi-best parse maxi-
mizing equation 10.
We implement max rule sum (MRS) in a similar
way, but do not only keep track of labels in every
cell, but of each CFG rule that span the specific yield
(see also Sima’an, 1999, 2003). We haven’t im-
plemented the max rule product (MRP) where pos-
teriors are multiplied instead of added (Petrov and
Klein, 2007; Bansal and Klein, 2010).
4 Experimental Setup
In order to build and test our Double-DOP model9,
we employ the Penn WSJ Treebank (Marcus et al.,
1993). We use sections 2-21 for training, section 24
for development and section 23 for testing.
Treebank binarization We start with some pre-
processing of the treebank, following standard prac-
9The software produced for running our model is publicly
available and included in the supplementary material to this pa-
per. To the best of our knowledge this is the first DOP software
released that can be used to parse the WSJ PTB.
90
S
NP|S
NP|S@NNP|NP
DT|NP
The
NNP|NP
Free
NNP|NP
French
VP|S
VBD|VP
wore
NP|VP
NP|VP@NN|NP
JJ|NP
black
NN|NP
arm
NNS|NP
bands
Figure 7: The binarized version of the tree in figure 1,
with H=1 and P=1.
tice in WSJ parsing. We remove traces and func-
tional tags. We apply a left binarization of the train-
ing treebank as in Matsuzaki et al. (2005) and Klein
and Manning (2003), setting the horizontal history
H=1 and the parent labeling P=1. This means that
when a node has more than 2 children, the ith child
(for i ? 3) is conditioned on child i ? 1. Moreover
the labels of all non-lexical nodes are enriched with
the labels of their parent node. Figure 7 shows the
binarized version of the tree structure in figure 1.
Unknownwords We replace words appearing less
than 5 times in the training data by one of 50 un-
known word categories based on the presence of lex-
ical features as implemented in Petrov (2009). In
some of the experiments we also perform a smooth-
ing over the lexical elements assigning low counts
( = 0.01) to open-class ?words, PoS-tags? pairs not
encountered in the training corpus10.
Fragment extraction We extract the symbolic
grammar and fragment frequencies from this prepro-
cessed treebank as explained in section 2. This is
the the most time-consuming step (around 160 CPU
hours11).
In the extracted grammar we have in total
1,029,342 recurring fragments and 17,768 unseen
CFG rules. We test several probability distributions
over the fragments (section 3.2) and various maxi-
mization objectives (section 3.3).
10A PoS-tag is an open class if it rewrites to at least 50 differ-
ent words in the training corpus. A word is an open class word
if it has been seen only with open-class PoS-tags.
11Although our code could still be optimized further, it does
already allow for running the job on M CPUs in parallel, reduc-
ing the time required by a factor M (10 hours with 16-CPUs).
86.086.587.087.588.0  
0
 
0.5
 
1 1.1
5
 
1.5
 
2
F1 / Recall / Precision (%)
?M
ax Co
nst. P
arse
Max 
Rule 
Sum
Max 
Proba
ble Pa
rse
Max 
Proba
ble D
erivat
ion
Precis
ion (M
CP)
F1 sc
ore (M
CP)
Recal
l (MCP
)
Figure 8: Double-DOP results on the development sec-
tion (? 40) with different maximizing objectives.
Parsing We convert our PTSG into a PCFG (sec-
tion 3.1) and use Bitpar12 for parsing. For approx-
imating MPP and other objectives we marginalize
probabilities from the 1,000 best derivations.
4.1 Results
We start by presenting in figure 8 the results we ob-
tain on the development set (section 24). Here we
compare the maximizing objectives presented in sec-
tion 3.3, using RFE to obtain the probability distri-
bution over the fragments. We conclude that, em-
pirically, MCP for ? = 1.15, is the best choice to
maximize F1, followed by MRS, MPP, and MPD.
We also compare the various estimators presented
in section 3.2, on the same development set, keep-
ing MCP with ? = 1.15 as the maximizing objec-
tive. We find that RFE is the best estimator (87.2
F113) followed by EWE (86.8) and ML (86.6). Our
best results with ML are obtained when removing
fragments occurring less than 6 times (apart from
CFG-rules) and when stopping at the second iter-
ation. This filtering is done in order to limit the
number of big fragments in the grammar. It is well
known that IO for DOP tends to assign most of the
probability mass to big fragments, quickly overfit-
ting the training data. It is surprising that EWE and
ML perform worse than RFE, in contrast to earlier
findings (Bod, 2003).
12http://www.ims.uni-stuttgart.de/tcl/
SOFTWARE/BitPar.html
13We computed F1 scores with EvalB (http://nlp.cs.
nyu.edu/evalb/) using parameter file new.prm.
91
 
80
 
81
 
82
 
83
 
84
 
85
 
86
 
87
 
88  1
 
10 2
0
 
50
 
1001
04105106107
F1
Number of fragments
Fragm
ent fr
equen
cy thr
eshol
d
F1
Doub
le-DO
P gra
mmar
 size
Num
ber of
 PCFG
 rules
Figure 9: Performance (on the development set) and size
of Double-DOP when considering only fragments whose
occurring frequency in the training treebank is above a
specific threshold (x-axis). In all cases, all PCFG-rules
are included in the grammars. For instance, at the right-
hand side of the plot a grammar is evaluated which in-
cluded only 6754 fragments with a frequency > 100 as
well as 39227 PCFG rules.
We also investigate how a further restriction on
the set of extracted fragments influences the perfor-
mance of our model. In figure 9 we illustrate the
performance of Double-DOP when restricting the
grammar to fragments having frequencies greater
than 1, 2, . . . , 100. We can notice a rather sharp
decrease in performance as the grammar becomes
more and more compact.
Next, we present some results on various Double-
DOP grammars extracted from the same training
treebank after refining it using the Berkeley state-
splitting model14 (Petrov et al., 2006; Petrov and
Klein, 2007). In total we have 6 increasingly refined
versions of the treebank, corresponding to the 6 cy-
cles of the Berkeley model. We observe in figure 10
that our grammar is able to benefit from the state
splits for the first four levels of refinement, reaching
the maximum score at cycle 4, where we improve
over our base model. For the last two data points, the
treebank gets too refined, and using Double-DOP
model on top of it, no longer improves accuracy.
We have also compared our best Double-DOP
14We use the Berkeley grammar labeler following the base
settings for the WSJ: trees are right-binarized, H=0, and
P=0. Berkeley parser package is available at http://code.
google.com/p/berkeleyparser/
 
74
 
76
 
78
 
80
 
82
 
84
 
86
 
88
 
90
 
92
 
1
 
2
 
3
 
4
 
5
 
6
F1
Berke
ley gr
amma
r/tree
bank 
refine
ment 
level
Berke
ley M
RP
Berke
ley M
PD
Doub
le-DO
P
Doub
le-DO
P Lex
 smoo
th
Figure 10: Comparison on section 24 between the per-
formance of Double-DOP (using RFE and MCP with
? = 1.15, H=0, P=0) and Berkeley parser on different
stages of refinement of the treebank/grammar.
base model and the Berkeley parser on per-category
performance. Here we observe an interesting trend:
the Berkeley parser outperforms Double-DOP on
very frequent categories, while Double-DOP per-
forms better on infrequent ones. A detailed com-
parison is included in table 1.
Finally, in table 2 we present our results on the
test set (section 23). Our best model (according to
the best settings on the development set) performs
slightly worse than the one by Bansal and Klein
(2010) when trained on the original corpus, but out-
performs it (and the version of their model with
additional refinements) when trained on the refined
version, in particular for the exact match score.
5 Conclusions
We have described Double-DOP, a novel DOP ap-
proach for parsing, which uses all constructions re-
curring at least twice in a treebank. This method-
ology is driven by the linguistic intuition that con-
structions included in the grammar should prove to
be reusable in a representative corpus.
The extracted set of fragments is significantly
smaller than in previous approaches. Moreover con-
structions are explicitly represented, which makes
them potentially good candidates as semantic or
translation units to be used in other applications.
Despite earlier reported excellent results with
DOP parsers, they are almost never used in other
92
Category % F1 F1label in gold Berkeley Double-DOPNP 41.42 91.4 89.5VP 20.46 90.6 88.6S 13.38 90.7 87.6PP 12.82 85.5 84.1SBAR 3.47 86.0 82.1ADVP 3.36 82.4 81.0ADJP 2.32 68.0 67.3QP 0.98 82.8 84.6WHNP 0.88 94.5 92.0WHADVP 0.33 92.8 91.9PRN 0.32 83.0 77.9NX 0.29 9.50 7.70SINV 0.28 90.3 88.1SQ 0.14 82.1 79.3FRAG 0.10 26.4 34.3SBARQ 0.09 84.2 88.2X 0.06 72.0 83.3NAC 0.06 54.6 88.0WHPP 0.06 91.7 44.4CONJP 0.04 55.6 66.7LST 0.03 61.5 33.3UCP 0.03 30.8 50.0INTJ 0.02 44.4 57.1
Table 1: Comparison of the performance (per-category
F1 score) on the development set between the Berkeley
parser and the best Double-DOP model.
NLP tasks: where other successful parsers often fea-
ture as components of machine translation, semantic
role labeling, question-answering or speech recogni-
tion systems, DOP is conspicuously absent in these
neighboring fields (but for a possible application of
closely related formalisms see, e.g., Yamangil and
Shieber, 2010). The reasons for this are many, but
most important are probably the computational inef-
ficiency of many instances of the approach, the lack
of downloadable software and the difficulties with
replicating some of the key results.
In this paper we have addressed all three obsta-
cles: our efficient algorithm for identifying the re-
current fragments in a treebank runs in polynomial
time. The transformation to PCFGs that we define
allows us to use a standard PCFG parser, while re-
taining the benefit of explicitly representing larger
fragments. A different transform also allows us to
run the popular inside-outside algorithm. Although
IO results are slightly worse than with the naive
relative frequency estimate, it is important to es-
tablish that the standard method for dealing with
latent information (i.e., the derivations of a given
parse) is not the best choice in this case. We expect
that other re-estimation methods, for instance Vari-
test (? 40) test (all)
Parsing Model F1 EX F1 EX
PCFG Baseline
PCFG (H=1, P=1) 77.6 17.2 76.5 15.9
PCFG (H=1, P=1) Lex smooth. 78.5 17.2 77.4 16.0
FRAGMENT-BASED PARSERS
Zuidema (2007)* 83.8 26.9 - -
Cohn et al. (2010) MRS 85.4 27.2 84.7 25.8
Post and Gildea (2009) 82.6 - - -
Bansal and Klein (2010) MCP 88.5 33.0 87.6 30.8
Bansal and Klein (2010) MCP 88.7 33.8 88.1 31.7
+ Additional Refinement
THIS PAPER
Double-DOP 87.7 33.1 86.8 31.0
Double-DOP Lex smooth. 87.9 33.7 87.0 31.5
Double-DOP-Sp 88.8 35.9 88.2 33.8
Double-DOP-Sp Lex smooth. 89.7 38.3 89.1 36.1
REFINEMENT-BASED PARSERS
Collins (1999) 88.6 - 88.2 -
Petrov and Klein (2007) 90.6 39.1 90.1 37.1
Table 2: Summary of the results of different parsers
on the test set (sec 23). Double-DOP experiments use
RFE, MCP with ? = 1.15, H=1, P=1; those on state-
splitting (Double-DOP-Sp) use Berkeley cycle 4, H=0,
P=0. Results from Petrov and Klein (2007) already in-
clude smoothing which is performed similarly to our
smoothing technique (see section 4). (* Results on a de-
velopment set, with sentences up to length 20.)
ational Bayesian techniques, could be formulated in
the same manner.
Finally, the availability of our programs, as well
as the third party software that we use, also ad-
dresses the replicability issue. Where some re-
searchers in the field have been skeptical of the DOP
approach to parsing, we believe that our independent
development of a DOP parser adds credibility to the
idea that an approach that uses very many large sub-
trees, can lead to very accurate parsers.
Acknowledgments
We gratefully acknowledge funding by the
Netherlands Organization for Scientific Research
(NWO): FS is funded through a Vici-grant “Inte-
grating Cognition” (277.70.006) to Rens Bod, and
WZ through a Veni-grant “Discovering Grammar”
(639.021.612). We also thank Rens Bod, Gideon
Borensztajn, Jos de Bruin, Andreas van Cranen-
burgh, Phong Le, Remko Scha, Khalil Sima’an and
the anonymous reviewers for very useful comments.
93
References
Mohit Bansal and Dan Klein. 2010. Simple, accu-
rate parsing with an all-fragments grammar. In
Proceedings of the 48th Annual Meeting of the
ACL, pages 1098–1107. Association for Compu-
tational Linguistics, Uppsala, Sweden.
Rens Bod. 1992. A computational model of lan-
guage performance: Data oriented parsing. In
Proceedings COLING’92 (Nantes, France), pages
855–859. Association for Computational Linguis-
tics, Morristown, NJ.
Rens Bod. 2001. What is the minimal set of frag-
ments that achieves maximal parse accuracy? In
Proceedings of the ACL. Morgan Kaufmann, San
Francisco, CA.
Rens Bod. 2003. An efficient implementation of a
new DOP model. In Proceedings of the tenth con-
ference on European chapter of the Association
for Computational Linguistics - Volume 1, EACL
’03, pages 19–26. Association for Computational
Linguistics, Morristown, NJ, USA.
Rens Bod, Khalil Sima’an, and Remko Scha. 2003.
Data-Oriented Parsing. University of Chicago
Press, Chicago, IL, USA.
Gideon Borensztajn, Willem Zuidema, and Rens
Bod. 2009. Children’s Grammars Grow More
Abstract with Age—Evidence from an Automatic
Procedure for Identifying the Productive Units of
Language. Topics in Cognitive Science, 1(1):175–
188.
Eugene Charniak. 1997. Statistical parsing with a
context-free grammar and word statistics. In Pro-
ceedings of the Fourteenth National Conference
on Artificial Intelligence, pages 598–603. AAAI
Press/MIT Press.
Eugene Charniak and Mark Johnson. 2005. Coarse-
to-fine n-best parsing and maxent discriminative
reranking. In Proc. 43nd Meeting of Association
for Computational Linguistics (ACL 2005).
Trevor Cohn, Phil Blunsom, and Sharon Goldwa-
ter. 2010. Inducing tree-substitution grammars.
Journal of Machine Learning Research, 11:3053–
3096.
Michael Collins and Nigel Duffy. 2001. Convolu-
tion Kernels for Natural Language. In Thomas G.
Dietterich, Suzanna Becker, and Zoubin Ghahra-
mani, editors, NIPS, pages 625–632. MIT Press.
Michael Collins and Nigel Duffy. 2002. New rank-
ing algorithms for parsing and tagging: Kernels
over discrete structures, and the voted percep-
tron. In Proceedings of 40th Annual Meeting of
the ACL, pages 263–270. Association for Compu-
tational Linguistics, Philadelphia, Pennsylvania,
USA.
Michael J. Collins. 1999. Head-Driven Statistical
Models for Natural Language Parsing. Ph.D. the-
sis, University of Pennsylvania.
Joshua Goodman. 1996. Efficient algorithms for
parsing the DOP model. In Proceedings of
the Conference on Empirical Methods in Natural
Language Processing, pages 143–152.
Joshua Goodman. 2003. Efficient parsing of DOP
with PCFG-reductions. In Bod et al. (2003).
Joshua T. Goodman. 1998. Parsing inside-out.
Ph.D. thesis, Harvard University, Cambridge,
MA, USA.
Ray Jackendoff. 2002. Foundations of Language.
Oxford University Press, Oxford, UK.
Mark Johnson. 2002. The dop estimation method is
biased and inconsistent. Computational Linguis-
tics, 28:71–76.
Mark Johnson, Thomas L. Griffiths, and Sharon
Goldwater. 2007. Adaptor grammars: A frame-
work for specifying compositional nonparametric
bayesian models. In Advances in Neural Informa-
tion Processing Systems, volume 16, pages 641–
648.
Dan Klein and Christopher D. Manning. 2003. Ac-
curate unlexicalized parsing. In ACL ’03: Pro-
ceedings of the 41st Annual Meeting on ACL,
pages 423–430. Association for Computational
Linguistics, Morristown, NJ, USA.
K. Lari and S. J. Young. 1990. The estimation
of stochastic context-free grammars using the
inside-outside algorithm. Computer Speech and
Language, 4:35–56.
Mitchell P. Marcus, Mary Ann Marcinkiewicz, and
Beatrice Santorini. 1993. Building a Large An-
notated Corpus of English: The Penn Treebank.
Computational Linguistics, 19(2):313–330.
94
Takuya Matsuzaki, Yusuke Miyao, and Jun’ichi
Tsujii. 2005. Probabilistic cfg with latent anno-
tations. In ACL ’05: Proceedings of the 43rd
Annual Meeting on ACL, pages 75–82. Associa-
tion for Computational Linguistics, Morristown,
NJ, USA.
Alessandro Moschitti. 2006. Efficient Convolution
Kernels for Dependency and Constituent Syntac-
tic Trees. In ECML, pages 318–329. Machine
Learning: ECML 2006, 17th European Confer-
ence on Machine Learning, Proceedings, Berlin,
Germany.
Timothy J. O’Donnell, Noah D. Goodman, and
Joshua B. Tenenbaum. 2009. Fragment Gram-
mars: Exploring Computation and Reuse in Lan-
guage. Technical Report MIT-CSAIL-TR-2009-
013, MIT.
Slav Petrov. 2009. Coarse-to-Fine Natural Lan-
guage Processing. Ph.D. thesis, University of
California at Bekeley, Berkeley, CA, USA.
Slav Petrov, Leon Barrett, Romain Thibaux, and
Dan Klein. 2006. Learning accurate, compact,
and interpretable tree annotation. In ACL-44:
Proceedings of the 21st International Conference
on Computational Linguistics and the 44th an-
nual meeting of the ACL, pages 433–440. Associ-
ation for Computational Linguistics, Morristown,
NJ, USA.
Slav Petrov and Dan Klein. 2007. Improved infer-
ence for unlexicalized parsing. In Human Lan-
guage Technologies 2007: The Conference of the
North American Chapter of the ACL; Proceedings
of the Main Conference, pages 404–411. Asso-
ciation for Computational Linguistics, Rochester,
New York.
Matt Post and Daniel Gildea. 2009. Bayesian learn-
ing of a tree substitution grammar. In Proceed-
ings of the ACL-IJCNLP 2009 Conference Short
Papers, pages 45–48. Association for Computa-
tional Linguistics, Suntec, Singapore.
Federico Sangati and Willem Zuidema. 2009. Unsu-
pervised Methods for Head Assignments. In Pro-
ceedings of the 12th Conference of the European
Chapter of the ACL (EACL 2009), pages 701–
709. Association for Computational Linguistics,
Athens, Greece.
Federico Sangati, Willem Zuidema, and Rens Bod.
2010. Efficiently extract recurring tree fragments
from large treebanks. In Proceedings of the
Seventh conference on International Language
Resources and Evaluation (LREC’10). European
Language Resources Association (ELRA), Val-
letta, Malta.
Remko Scha. 1990. Taaltheorie en taaltechnolo-
gie: competence en performance. In Q. A. M.
de Kort and G. L. J. Leerdam, editors, Com-
putertoepassingen in de Neerlandistiek, LVVN-
jaarboek, pages 7–22. Landelijke Vereniging van
Neerlandici, Almere. [Language theory and
language technology: Competence and Perfor-
mance] in Dutch.
Khalil Sima’an. 1996. Computational complexity
of probabilistic disambiguation by means of tree-
grammars. In Proceedings of the 16th conference
on Computational linguistics, pages 1175–1180.
Association for Computational Linguistics, Mor-
ristown, NJ, USA.
Khalil Sima’an. 1999. Learning Efficient Disam-
biguation. Ph.D. thesis, Utrecht University and
University of Amsterdam.
Khalil Sima’an. 2003. On maximizing metrics for
syntactic disambiguation. In Proceedings of the
International Workshop on Parsing Technologies
(IWPT’03).
Elif Yamangil and Stuart M. Shieber. 2010.
Bayesian synchronous tree-substitution grammar
induction and its application to sentence compres-
sion. In Proceedings of the 48th Annual Meeting
of the ACL, ACL ’10, pages 937–947. Associa-
tion for Computational Linguistics, Stroudsburg,
PA, USA.
Andreas Zollmann and Khalil Sima’an. 2005.
A consistent and efficient estimator for data-
oriented parsing. Journal of Automata, Lan-
guages and Combinatorics, 10(2/3):367–388.
Willem Zuidema. 2007. Parsimonious Data-
Oriented Parsing. In Proceedings of the 2007
Joint Conference on Empirical Methods in Nat-
ural Language Processing and Computational
Natural Language Learning (EMNLP-CoNLL),
pages 551–560. Association for Computational
Linguistics, Prague, Czech Republic.
95
