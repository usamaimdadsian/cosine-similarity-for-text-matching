Proceedings of the 2008 Conference on Empirical Methods in Natural Language Processing, pages 31–40,
Honolulu, October 2008. c©2008 Association for Computational Linguistics
Modeling Annotators:
A Generative Approach to Learning from Annotator Rationales?
Omar F. Zaidan and Jason Eisner
Dept. of Computer Science, Johns Hopkins University
Baltimore, MD 21218, USA
{ozaidan,jason}@cs.jhu.edu
Abstract
A human annotator can provide hints to a machine learner
by highlighting contextual “rationales” for each of his
or her annotations (Zaidan et al., 2007). How can one
exploit this side information to better learn the desired
parameters ?? We present a generative model of how
a given annotator, knowing the true ?, stochastically
chooses rationales. Thus, observing the rationales helps
us infer the true ?. We collect substring rationales for
a sentiment classification task (Pang and Lee, 2004) and
use them to obtain significant accuracy improvements for
each annotator. Our new generative approach exploits the
rationales more effectively than our previous “masking
SVM” approach. It is also more principled, and could be
adapted to help learn other kinds of probabilistic classi-
fiers for quite different tasks.
1 Background
Many recent papers aim to reduce the amount of an-
notated data needed to train the parameters of a sta-
tistical model. Well-known paradigms include ac-
tive learning, semi-supervised learning, and either
domain adaptation or cross-lingual transfer from ex-
isting annotated data.
A rather different paradigm is to change the ac-
tual task that is given to annotators, giving them a
greater hand in shaping the learned classifier. Af-
ter all, human annotators themselves are more than
just black-box classifiers to be run on training data.
They possess some introspective knowledge about
their own classification procedure. The hope is to
mine this knowledge rapidly via appropriate ques-
tions and use it to help train a machine classifier.
How to do this, however, is still being explored.
1.1 Hand-crafted rules
An obvious option is to have the annotators directly
express their knowledge by hand-crafting rules. This
?This work was supported by National Science Foundation
grant No. 0347822 and the JHU WSE/APL Partnership Fund.
Special thanks to Christine Piatko for many useful discussions.
approach remains “data-driven” if the annotators re-
peatedly refine their system against a corpus of la-
beled or unlabeled examples. This achieves high
performance in some domains, such as NP chunk-
ing (Brill and Ngai, 1999), but requires more analyt-
ical skill from the annotators. One empirical study
(Ngai and Yarowsky, 2000) found that it also re-
quired more annotation time than active learning.
1.2 Feature selection by humans
More recent work has focused on statistical classi-
fiers. Training such classifiers faces the “credit as-
signment problem.” Given a training example xwith
many features, which features are responsible for its
annotated class y? It may take many training exam-
ples to distinguish useful vs. irrelevant features.1
To reduce the number of training examples
needed, one can ask annotators to examine or pro-
pose some candidate features. This is possible even
for the very large feature sets that are typically used
in NLP. In document classification, Raghavan et al.
(2006) show that feature selection by an oracle could
be helpful, and that humans are both rapid and rea-
sonably good at distinguishing highly useful n-gram
features from randomly chosen ones, even when
viewing these n-grams out of context.
Druck et al. (2008) show annotators some features
f from a fixed feature set, and ask them to choose a
class label y such that p(y | f) is as high as possible.
Haghighi and Klein (2006) do the reverse: for each
class label y, they ask the annotators to propose a
few “prototypical” features f such that p(y | f) is as
high as possible.
1.3 Feature selection in context
The above methods consider features out of context.
An annotator might have an easier time examining
1Most NLP systems use thousands or millions of features,
because it is helpful to include lexical features over a large vo-
cabulary, often conjoined with lexical or non-lexical context.
31
features in context to recognize whether they appear
relevant. This is particularly true for features that
are only modestly or only sometimes helpful, which
may be abundant in NLP tasks.
Thus, Raghavan et al. (2006) propose an active
learning method in which, while classifying a train-
ing document, the annotator also identifies some fea-
tures of that document as particularly relevant. E.g.,
the annotator might highlight particular unigrams as
he or she reads the document. In their proposal, a
feature that is highlighted in any document is as-
sumed to be globally more relevant. Its dimension
in feature space is scaled by a factor of 10 so that
this feature has more influence on distances or inner
products, and hence on the learned classifier.
1.4 Concerns about marking features
Despite the success of the above work, we have
several concerns about asking annotators to identify
globally relevant features.
First, a feature in isolation really does not have a
well-defined worth. A feature may be useful only in
conjunction with other features,2 or be useful only
to the extent that other correlated features are not
selected to do the same work.
Second, it is not clear how an annotator would
easily view and highlight features in context, ex-
cept for the simplest feature sets. In the phrase
Apple shares up 3%, there may be several fea-
tures that fire on the substring Apple—responding
to the string Apple, its case-invariant form apple,
its lemma apple- (which would also respond to ap-
ples), its context-dependent sense Apple2, its part
of speech noun, etc. How does the annotator indi-
cate which of these features are relevant?
Third, annotating features is only appropriate
when the feature set can be easily understood by a
human. This is not always the case. It would be hard
for annotators to read, write, or evaluate a descrip-
tion of a complex syntactic configuration in NLP or
a convolution filter in machine vision.
Fourth, traditional annotation efforts usually try to
remain agnostic about the machine learning methods
2For example, a linear classifier can learn that most training
examples satisfyA? B by setting ?A = ?5 and ?A?B = +5,
but this solution requires selecting bothA andA?B as features.
More simply, a polynomial kernel can consider the conjunction
A ?B only if both A and B are selected as features.
and features to be used. The project’s cost is justi-
fied by saying that the annotations will be reused by
many researchers (perhaps in a “shared task”), who
are free to compete on how they tackle the learning
problem. Unfortunately, feature annotation commits
to a particular feature set at annotation time. Subse-
quent research cannot easily adjust the definition of
the features, or obtain annotation of new features.
2 Annotating Rationales
To solve these problems, we propose that annotators
should not select features but rather mark relevant
portions of the example. In earlier work (Zaidan et
al., 2007), we called these markings “rationales.”
For example, when classifying a movie review as
positive or negative, the annotator would also high-
light phrases that supported that judgment. Figure 1
shows two such rationales.
A multi-annotator timing study (Zaidan et al.,
2007) found that highlighting rationale phrases
while reading movie reviews only doubled annota-
tion time, although annotators marked 5–11 ratio-
nale substrings in addition to the simple binary class.
The benefit justified the extra time. Furthermore,
much of the benefit could have been obtained by giv-
ing rationales for only a fraction of the reviews.
In the visual domain, when classifying an im-
age as containing a zoo, the annotator might circle
some animals or cages and the sign reading “Zoo.”
The Peekaboom game (von Ahn et al., 2006) was in
fact built to elicit such approximate yet relevant re-
gions of images. Further scenarios were discussed in
(Zaidan et al., 2007): rationale annotation for named
entities, linguistic relations, or handwritten digits.
Annotating rationales does not require the anno-
tator to think about the feature space, nor even to
know anything about it. Arguably this makes an-
notation easier and more flexible. It also preserves
the reusability of the annotated data. Anyone is free
to reuse our collected rationales (section 4) to aid
in learning a classifier with richer features, or a dif-
ferent kind of classifier altogether, using either our
procedures or novel procedures.
3 Modeling Rationale Annotations
As rationales are more indirect than explicit features,
they present a trickier machine learning problem.
32
We wish to learn the parameters ? of some classi-
fier. How can the annotator’s rationales help us to
do this without many training examples? We will
have to exploit a presumed relationship between the
rationales and the optimal value of ? (i.e., the value
that we would learn on an infinite training set).
This paper exploits an explicit, parametric model
of that relationship. The model’s parameters ? are
intended to capture what that annotator is doing
when he or she marks rationales. Most importantly,
they capture how he or she is influenced by the true
?. Given this, our learning method will prefer values
of ? that would adequately explain the rationales (as
well as the training classifications).
3.1 A generative approach
For concreteness, we will assume that the task is
document classification. Our training data consists
of n triples {(x1, y1, r1), ..., (xn, yn, rn)}), where xi
is a document, yi is its annotated class, and ri is its
rationale markup. At test time we will have to pre-
dict yn+1 from xn+1, without any rn+1.
We propose to jointly choose parameter vectors ?
and ? to maximize the following regularized condi-
tional likelihood:3
n?
i=1
p(yi, ri | xi, ?, ?) · pprior(?, ?) (1)
def
=
n?
i=1
p?(yi | xi) · p?(ri | xi, yi, ?) · pprior(?, ?)
Here we are trying to model all the annotations, both
yi and ri. The first factor predicts yi using an ordi-
nary probabilistic classifier p?, while the novel sec-
ond factor predicts ri using a model p? of how an-
notators generate the rationale annotations.
The crucial point is that the second factor depends
on ? (since ri is supposed to reflect the relation be-
tween xi and yi that is modeled by ?). As a result,
the learner has an incentive to modify ? in a way
that increases the second factor, even if this some-
what decreases the first factor on training data.4
3It would be preferable to integrate out ? (and even ?), but
more difficult.
4Interestingly, even examples where the annotation yi is
wrong or unhelpful can provide useful information about ? via
the pair (yi, ri). Two annotators marking the same movie re-
view might disagree on whether it is overall a positive or nega-
After training, one should simply use the first fac-
tor p?(y | x) to classify test documents x. The sec-
ond factor is irrelevant for test documents, since they
have not been annotated with rationales r.
The second factor may likewise be omitted for any
training documents i that have not been annotated
with rationales, as there is no ri to predict in those
cases. In the extreme case where no documents are
annotated with rationales, equation (1) reduces to
the standard training procedure.
3.2 Noisy channel design of rationale models
Like ordinary class annotations, rationale annota-
tions present us with a “credit assignment problem,”
albeit a smaller one that is limited to features that fire
“in the vicinity” of the rationale r. Some of these
?-features were likely responsible for the classifica-
tion y and hence triggered the rationale. Other such
?-features were just innocent bystanders.
Thus, the interesting part of our model is p?(r |
x, y, ?), which models the rationale annotation pro-
cess. The rationales r reflect ?, but in noisy ways.
Taking this noisy channel idea seriously, p?(r |
x, y, ?) should consider two questions when assess-
ing whether r is a plausible set of rationales given
?. First, it needs a “language model” of rationales:
does r consist of rationales that are well-formed a
priori, i.e., before ? is considered? Second, it needs
a “channel model”: does r faithfully signal the fea-
tures of ? that strongly support classifying x as y?
If a feature contributes heavily to the classification
of document x as class y, then the channel model
should tell us which parts of document x tend to be
highlighted as a result.
The channel model must know about the partic-
ular kinds of features that are extracted by f and
scored by ?. Suppose the feature not . . . gripping,5
with weight ?h, is predictive of the annotated class y.
This raises the probabilities of the annotator’s high-
lighting each of various words, or combinations of
words, in a phrase like not the most gripping ban-
quet on film. The channel model parameters in ?
tive review—but the second factor still allows learning positive
features from the first annotator’s positive rationales, and nega-
tive features from the second annotator’s negative rationales.
5Our current experiments use only unigram features, to
match past work, but we use this example to outline how our
approach generalizes to complex linguistic (or visual) features.
33
should specify how much each of these probabilities
is raised, based on the magnitude of ?h ? R, the
class y, and the fact that the feature is an instance
of the template <Neg> . . .<Adjective>. (Thus, ?
has no parameters specific to the word gripping; it
is a low-dimensional vector that only describes the
annotator’s general style in translating ? into r.)
The language model, however, is independent of
the feature set ?. It models what rationales tend to
look like in the input domain—e.g., documents or
images. In the document case, ? should describe:
How frequent and how long are typical rationales?
Do their edges tend to align with punctuation or ma-
jor syntactic boundaries in x? Are they rarer in the
middle of a document, or in certain documents?6
Thanks to the language model, we do not need to
posit high ? features to explain every word in a ratio-
nale. The language model can “explain away” some
words as having been highlighted only because this
annotator prefers not to end a rationale in mid-
phrase, or prefers to sweep up close-together fea-
tures with a single long rationale rather than many
short ones. Similarly, the language model can help
explain why some words, though important, might
not have been included in any rationale of r.
If there are multiple annotators, one can learn dif-
ferent ? parameters for each annotator, reflecting
their different annotation styles.7 We found this to
be useful (section 8.2).
We remark that our generative modeling approach
(equation (1)) would also apply if r were not ratio-
nale markup, but some other kind of so-called “side
information,” such as the feature annotations dis-
cussed in section 1. For example, Raghavan et al.
(2006) assume that if feature h is relevant—a bi-
6Our current experiments do not model this last point. How-
ever, we imagine that if the document only has a few ?-features
that support the classification, the annotator will probably mark
most of them, whereas if such features are abundant, the anno-
tator may lazily mark only a few of the strongest ones. A simple
approach would equip ? with a different “bias” or “threshold”
parameter ?x for each rationale training document x, to mod-
ulate the a priori probability of marking a rationale in x. By
fitting this bias parameter, we deduce how lazy the annotator
was (for whatever reason) on document x. If desired, a prior
on ?x could consider whether x has many strong ?-features,
whether the annotator has recently had a coffee break, etc.
7Given insufficient rationale data to recover some annota-
tor’s ?well, one could smooth using data from other annotators.
But in our situation, ? had relatively few parameters to learn.
nary distinction—iff it was selected in at least one
document. But it might be more informative to ob-
serve that h was selected in 3 of the 10 documents
where it appeared, and to predict this via a model
p?(3 of 10 | ?h), where ? describes (e.g.) how to de-
rive a binomial parameter nonlinearly from ?h. This
approach would not how often h was marked and in-
fer how relevant is feature h (i.e., infer ?h). In this
case, p? is a simple channel that transforms relevant
features into direct indicators of the feature. Our
side information merely requires a more complex
transformation—from relevant features into well-
formed rationales, modulated by documents.
4 Experimental Data: Movie Reviews
In Zaidan et al. (2007), we introduced the “Movie
Review Polarity Dataset Enriched with Annotator
Rationales.”8 It is based on the dataset of Pang and
Lee (2004),9 which consists of 1000 positive and
1000 negative movie reviews, tokenized and divided
into 10 folds (F0–F9). All our experiments use F9
as their final blind test set.
The enriched dataset adds rationale annotations
produced by an annotator A0, who annotated folds
F0–F8 of the movie review set with rationales (in the
form of textual substrings) that supported the gold-
standard classifications. We will use A0’s data to
determine the improvement of our method over a
(log-linear) baseline model without rationales. We
also use A0 to compare against the “masking SVM”
method and SVM baseline of Zaidan et al. (2007).
Since ? can be tuned to a particular annotator, we
would also like to know how well this works with
data from annotators other than A0. We randomly
selected 100 reviews (50 positive and 50 negative)
and collected both class and rationale annotation
data from each of six new annotators A3–A8,10 fol-
lowing the same procedures as (Zaidan et al., 2007).
We report results using only data from A3–A5, since
we used the data from A6–A8 as development data
in the early stages of our work.
We use this new rationale-enriched dataset8 to de-
termine if our method works well across annotators.
We will only be able to carry out that comparison
8Available at http://cs.jhu.edu/?ozaidan/rationales.
9Polarity dataset version 2.0.
10We avoid annotator names A1–A2, which were already
used in (Zaidan et al., 2007).
34
Figure 1: Rationales as sequence an-
notation: the annotator highlighted
two textual segments as rationales for
a positive class. Highlighted words in
~x are tagged I in ~r, and other words
are tagged O. The figure also shows
some ?-features. For instance, gO(,)-I
is a count of O-I transitions that occur
with a comma as the left word. Notice
also that grel is the sum of the under-
lined values.
at small training set sizes, due to limited data from
A3–A8. The larger A0 dataset will still allow us to
evaluate our method on a range of training set sizes.
5 Detailed Models
5.1 Modeling class annotations with p?
We define the basic classifier p? in equation (1) to be
a standard conditional log-linear model:
p?(y | x)
def
=
exp(~? · ~f(x, y))
Z?(x)
def
=
u(x, y)
Z?(x)
(2)
where ~f(·) extracts a feature vector from a classified
document, ~? are the corresponding weights of those
features, and Z?(x)
def
=
?
y u(x, y) is a normalizer.
We use the same set of binary features as in pre-
vious work on this dataset (Pang et al., 2002; Pang
and Lee, 2004; Zaidan et al., 2007). Specifically, let
V = {v1, ..., v17744} be the set of word types with
count ? 4 in the full 2000-document corpus. Define
fh(x, y) to be y if vh appears at least once in x, and
0 otherwise. Thus ? ? R17744, and positive weights
in ? favor class label y = +1 and equally discourage
y = ?1, while negative weights do the opposite.
This standard unigram feature set is linguistically
impoverished, but serves as a good starting point for
studying rationales. Future work should consider
more complex features and how they are signaled by
rationales, as discussed in section 3.2.
5.2 Modeling rationale annotations with p?
The rationales collected in this task are textual seg-
ments of a document to be classified. The docu-
ment itself is a word token sequence ~x = x1, ..., xM .
We encode its rationales as a corresponding tag se-
quence ~r = r1, ..., rM , as illustrated in Figure 1.
Here rm ? {I, O} according to whether the token
xm is in a rationale (i.e., xm was at least partly high-
lighted) or outside all rationales. x1 and xM are
special boundary symbols, tagged with O.
We predict the full tag sequence ~r at once using
a conditional random field (Lafferty et al., 2001). A
CRF is just another conditional log-linear model:
p?(r |x, y, ~?)
def
=
exp(~? · ~g(r, x, y, ~?))
Z?(x, y, ~?)
def
=
u(r, x, y, ~?)
Z?(x, y, ~?)
where ~g(·) extracts a feature vector, ~? are the
corresponding weights of those features, and
Z?(x, y, ~?)
def
=
?
r u(r, x, y,
~?) is a normalizer.
As usual for linear-chain CRFs, ~g(·) extracts two
kinds of features: first-order “emission” features that
relate rm to (xm, y, ?), and second-order “transi-
tion” features that relate rm to rm?1 (although some
of these also look at x).
These two kinds of features respectively capture
the “channel model” and “language model” of sec-
tion 3.2. The former says rm is I because xm is
associated with a relevant ?-feature. The latter says
rm is I simply because it is next to another I.
5.3 Emission ?-features (“channel model”)
Recall that our ?-features (at present) correspond to
unigrams. Given (~x, y, ~?), let us say that a unigram
w ? ~x is relevant, irrelevant, or anti-relevant if
y · ?w is respectively 0, ? 0, or 0. That is, w
is relevant if its presence in x strongly supports the
annotated class y, and anti-relevant if its presence
strongly supports the opposite class ?y.
35
Figure 2: The
function family Bs
in equation (3),
shown for s ?
{10, 2,?2,?10}.
We would like to learn the extent ?rel to which
annotators try to include relevant unigrams in their
rationales, and the (usually lesser) extent ?antirel to
which they try to exclude anti-relevant unigrams.
This will help us infer ~? from the rationales.
The details are as follows. ?rel and ?antirel are the
weights of two emission features extracted by ~g:
grel(~x, y, ~r, ~?)
def
=
M?
m=1
I(rm = I) ·B10(y · ?xm)
gantirel(~x, y, ~r, ~?)
def
=
M?
m=1
I(rm = I) ·B?10(y · ?xm)
Here I(·) denotes the indicator function, returning
1 or 0 according to whether its argument is true or
false. Relevance and negated anti-relevance are re-
spectively measured by the differentiable nonlinear
functions B10 and B?10, which are defined by
Bs(a) = (log(1 + exp(a · s))? log(2))/s (3)
and graphed in Figure 2. Sample values of B10 and
grel are shown in Figure 1.
How does this work? The grel feature is a sum
over all unigrams in the document ~x. It does not fire
strongly on the irrelevant or anti-relevant unigrams,
since B10 is close to zero there.11 But it fires posi-
tively on relevant unigrams w if they are tagged with
I, and the strength of such firing increases approxi-
mately linearly with ?w. Since the weight ?rel > 0 in
practice, this means that raising a relevant unigram’s
?w (if y = +1) will proportionately raise its log-
odds of being tagged with I. Symmetrically, since
?antirel > 0 in practice, lowering an anti-relevant un-
igram’s ?w (if y = +1) will proportionately lower
11B10 sets the threshold for relevance to be about 0. One
could also include versions of the grel feature that set a higher
threshold, using B10(y · ?xm ? threshold).
its log-odds of being tagged with I, though not nec-
essarily at the same rate as for relevant unigrams.12
Should ? also include traditional CRF emis-
sion features, which would recognize that particular
words like great tend to be tagged as I? No! Such
features would undoubtedly do a better job predict-
ing the rationales and hence increasing equation (1).
However, crucially, our true goal is not to predict
the rationales but to recover the classifier parame-
ters ?. Thus, if great tends to be highlighted, then
the model should not be permitted to explain this
directly by increasing some feature ?great, but only
indirectly by increasing ?great. We therefore permit
our rationale prediction model to consider only the
two emission features grel and gantirel, which see the
words in ~x only through their ?-values.
5.4 Transition ?-features (“language model”)
Annotators highlight more than just the relevant un-
igrams. (After all, they aren’t told that our current
?-features are unigrams.) They tend to mark full
phrases, though perhaps taking care to exclude anti-
relevant portions. ?models these phrases’ shape, via
weights for several “language model” features.
Most important are the 4 traditional CRF tag tran-
sition features gO-O, gO-I, gI-I, gI-O. For example,
gO-I counts the number of O-to-I transitions in ~r
(see Figure 1). Other things equal, an annotator with
high ?O-I is predicted to have many rationales per
1000 words. And if ?I-I is high, rationales are pre-
dicted to be long phrases (including more irrelevant
unigrams around or between the relevant ones).
We also learn more refined versions of these fea-
tures, which consider how the transition probabil-
ities are influenced by the punctuation and syntax
of the document ~x (independent of ~?). These re-
fined features are more specific and hence more
sparsely trained. Their weights reflect deviations
from the simpler, “backed-off” transition features
such as gO-I. (Again, see Figure 1 for examples.)
Conditioning on left word. A feature of the form
gt1(v)-t2 is specified by a pair of tag types t1, t2 ?
{I,O} and a vocabulary word type v. It counts the
12If the two rates are equal (?rel = ?antirel), we get a simpler
model in which the log-odds change exactly linearly with ?w for
each w, regardless of w’s relevance/irrelevance/anti-relevance.
This follows from the fact thatBs(a)+B?s(a) simplifies to a.
36
number of times an t1–t2 transition occurs in ~r con-
ditioned on v appearing as the first of the two word
tokens where the transition occurs. Our experiments
include gt1(v)-t2 features that tie I-O and O-I tran-
sitions to the 4 most frequent punctuation marks v
(comma, period, ?, !).
Conditioning on right word. A feature gt1-t2(v)
is similar, but v must appear as the second of the
two word tokens where the transition occurs. Again
here, we use gt1-t2(v) features that tie I-O and O-I
transitions to the four punctuation marks mentioned
above. We also include five features that tie O-I
transitions to the words no, not, so, very, and quite,
since in our development data, those words were
more likely than others to start rationales.13
Conditioning on syntactic boundary. We parsed
each rationale-annotated training document (no
parsing is needed at test time).14 We then marked
each word bigram x1-x2 with three nonterminals:
NEnd is the nonterminal of the largest constituent
that contains x1 and not x2, NStart is the nontermi-
nal of the largest constituent that contains x2 and
not x1, and NCross is the nonterminal of the smallest
constituent that contains both x1 and x2.
For a nonterminalN and pair of tag types (t1, t2),
we define three features, gt1-t2/E=N , gt1-t2/S=N ,
and gt1-t2/C=N , which count the number of times
a t1-t2 transition occurs in ~r with N matching the
NEnd, NStart, or NCross nonterminal, respectively.
Our experiments include these features for 11 com-
mon nonterminal types N (DOC, TOP, S, SBAR,
FRAG, PRN, NP, VP, PP, ADJP, QP).
6 Training: Joint Optimization of ? and ?
To train our model, we use L-BFGS to locally max-
imize the log of the objective function (1):15
13These are the function words with count ? 40 in a random
sample of 100 documents, and which were associated with the
O-I tag transition at more than twice the average rate. We do
not use any other lexical ?-features that reference ~x, for fear that
they would enable the learner to explain the rationales without
changing ? as desired (see the end of section 5.3).
14We parse each sentence with the Collins parser (Collins,
1999). Then the document has one big parse tree, whose root is
DOC, with each sentence being a child of DOC.
15One might expect this function to be convex because p? and
p? are both log-linear models with no hidden variables. How-
ever, log p?(ri | xi, yi, ?) is not necessarily convex in ?.
n?
i=1
log p?(yi | xi)?
1
2?2?
???2
+C(
n?
i=1
log p?(ri | xi, yi, ?))?
1
2?2?
???2 (4)
This defines pprior from (1) to be a standard diago-
nal Gaussian prior, with variances ?2? and ?
2
? for the
two sets of parameters. We optimize ?2? in our ex-
periments. As for ?2?, different values did not affect
the results, since we have a large number of {I,O}
rationale tags to train relatively few ? weights; so
we simply use ?2? = 1 in all of our experiments.
Note the new C factor in equation (4). Our ini-
tial experiments showed that optimizing equation (4)
without C led to an increase in the likelihood of the
rationale data at the expense of classification accu-
racy, which degraded noticeably. This is because
the second sum in (4) has a much larger magnitude
than the first: in a set of 100 documents, it predicts
around 74,000 binary {I,O} tags, versus the one
hundred binary class labels. While we are willing
to reduce the log-likelihood of the training classifi-
cations (the first sum) to a certain extent, focusing
too much on modeling rationales (the second sum)
is clearly not our ultimate goal, and so we optimize
C on development data to achieve some balance be-
tween the two terms of equation (4). Typical values
of C range from 1300 to
1
50 .
16
We perform alternating optimization on ? and ?:
1. Initialize ? to maximize equation (4) but with
C = 0 (i.e. based only on class data).
2. Fix ?, and find ? that maximizes equation (4).
3. Fix ?, and find ? that maximizes equation (4).
4. Repeat 2 and 3 until convergence.
The L-BFGS method requires calculating the gra-
dient of the objective function (4). The partial
derivatives with respect to components of ? and ?
involve calculating expectations of the feature func-
tions, which can be computed in linear time (with
respect to the size of the training set) using the
forward-backward algorithm for CRFs. The par-
tial derivatives also involve the derivative of (3),
to determine how changing ? will affect the firing
strength of the emission features grel and gantirel.
16C also balances our confidence in the classifications y
against our confidence in the rationales r; either may be noisy.
37
7 Experimental Procedures
We report on two sets of experiments. In the first
set, we use the annotation data that A3–A5 provided
for the small set of 100 documents (as well as the
data from A0 on those same 100 documents). In
the second set, we used A0’s abundant annotation
data to evaluate our method with training set sizes up
to 1600 documents, and compare it with three other
methods: log-linear baseline, SVM baseline, and the
SVM masking method of (Zaidan et al., 2007).
7.1 Learning curves
The learning curves reported in section 8.1 are gen-
erated exactly as in (Zaidan et al., 2007). Each curve
shows classification accuracy at training set sizes
T = 1, 2, ..., 9 folds (i.e. 200, 400, ..., 1600 training
documents). For a given size T , the reported accu-
racy is an average of 9 experiments with different
subsets of the entire training set, each of size T :
1
9
8?
i=0
acc(F9 | Fi+1 ? . . . ? Fi+T ) (5)
where Fj denotes the fold numbered j mod 9, and
acc(F9 | Y ) means classification accuracy on the
held-out test set F9 after training on set Y .
We use an appropriate paired permutation test, de-
tailed in (Zaidan et al., 2007), to test differences in
(5). We call a difference significant at p < 0.05.
7.2 Comparison to “masking SVM” method
We compare our method to the “masking SVM”
method of (Zaidan et al., 2007). Briefly, that method
used rationales to construct several so-called con-
trast examples from every training example. A con-
trast example is obtained by “masking out” one of
the rationales highlighted to support the training ex-
ample’s class. A good classifier should have more
trouble on this modified example. Hence, Zaidan et
al. (2007) required the learned SVM to classify each
contrast example with a smaller margin than the cor-
responding original example (and did not require it
to be classified correctly).
The masking SVM learner relies on a simple geo-
metric principle; is trivial to implement on top of an
existing SVM learner; and works well. However, we
believe that the generative method we present here is
more interesting and should apply more broadly.
Figure 3: Classification accuracy curves for the 4 meth-
ods: the two baseline learners that only utilize class data,
and the two learners that also utilize rationale annota-
tions. The SVM curves are from (Zaidan et al., 2007).
First, the masking method is specific to improving
an SVM learner, whereas our method can be used to
improve any classifier by adding a rationale-based
regularizer (the second half of equation (4)) to its
objective function during training.
More important, there are tasks where it is unclear
how to generate contrast examples. For the movie
review task, it was natural to mask out a rationale
by pretending its words never occurred in the doc-
ument. After all, most word types do not appear in
most documents, so it is natural to consider the non-
presence of a word as a “default” state to which we
can revert. But in an image classification task, how
should one modify the image’s features to ignore
some spatial region marked as a rationale? There is
usually no natural “default” value to which we could
set the pixels. Our method, on the other hand, elim-
inates contrast examples altogether.
8 Experimental Results and Analysis
8.1 The added benefit of rationales
Fig. 3 shows learning curves for four methods. A
log-linear model shows large and significant im-
provements, at all training sizes, when we incor-
porate rationales into its training via equation (4).
Moreover, the resulting classifier consistently out-
performs17 prior work, the masking SVM, which
starts with a slightly better baseline classifier (an
SVM) but incorporates the rationales more crudely.
17Differences are not significant at sizes 200, 1000, and 1600.
38
size A0 A3 A4 A5
SVM baseline 100 72.0 72.0 72.0 70.0
SVM+contrasts 100 75.0 73.0 74.0 72.0
Log-linear baseline 100 71.0 73.0 71.0 70.0
Log-linear+rats 100 76.0 76.0 77.0 74.0
SVM baseline 20 63.4 62.2 60.4 62.6
SVM+contrasts 20 65.4 63.4 62.4 64.8
Log-linear baseline 20 63.0 62.2 60.2 62.4
Log-linear+rats 20 65.8 63.6 63.4 64.8
Table 1: Accuracy rates using each annotator’s data. In a
given column, a value in italics is not significantly differ-
ent from the highest value in that column, which is bold-
faced. The size=20 results average over 5 experiments.
To confirm that we could successfully model an-
notators other than A0, we performed the same
comparison for annotators A3–A5; each had pro-
vided class and rationale annotations on a small 100-
document training set. We trained a separate ? for
each annotator. Table 1 shows improvements over
baseline, usually significant, at 2 training set sizes.
8.2 Analysis
Examining the learned weights ~? gives insight into
annotator behavior. High weights include I-O and
O-I transitions conditioned on punctuation, e.g.,
?I(.)-O = 3.55,
18 as well as rationales ending at the
end of a major phrase, e.g., ?I-O/E=VP = 1.88.
The large emission feature weights, e.g., ?rel =
14.68 and ?antirel = 15.30, tie rationales closely to
? values, as hoped. For example, in Figure 1, the
word w = succeeds, with ?w = 0.13, drives up
p(I)/p(O) by a factor of 7 (in a positive document)
relative to a word with ?w = 0.
In fact, feature ablation experiments showed that
almost all the classification benefit from rationales
can be obtained by using only these 2 emission
?-features and the 4 unconditioned transition ?-
features. Our full ? (115 features) merely improves
our ability to predict the rationales (whose likeli-
hood does increase significantly with more features).
We also checked that annotators’ styles differ
enough that it helps to tune ? to the “target” annota-
torAwho gave the rationales. Table 3 shows that a ?
model trained onA’s own rationales does best at pre-
dicting new rationales fromA. Table 2 shows that as
18When trained on folds F4–F8 with A0’s rationales.
?A0 ?A3 ?A4 ?A5 Baseline
?A0 76.0 73.0 74.0 73.0 71.0
?A3 73.0 76.0 74.0 73.0 73.0
?A4 75.0 73.0 77.0 74.0 71.0
?A5 74.0 71.0 72.0 74.0 70.0
Table 2: Accuracy rate for an annotator’s ? (rows) ob-
tained when using some other annotator’s ? (columns).
Notice that the diagonal entries and the baseline column
are taken from rows of Table 1 (size=100).
Trivial
?A0 ?A3 ?A4 ?A5 model
?L(rA0) 0.073 0.086 0.077 0.088 0.135
?L(rA3) 0.084 0.068 0.071 0.068 0.130
?L(rA4) 0.088 0.084 0.075 0.085 0.153
?L(rA5) 0.058 0.044 0.047 0.044 0.111
Table 3: Cross-entropy per tag of rationale annotations
~r for each annotator (rows), when predicted from that
annotator’s ~x and ~? via a possibly different annotator’s
? (columns). For comparison, the trivial model is a bi-
gram model of ~r, which is trained on the target annotator
but ignores ~x and ~?. 5-fold cross-validation on the 100-
document set was used to prevent testing on training data.
a result, classification performance on the test set is
usually best if it wasA’s own ? that was used to help
learn ? from A’s rationales. In both cases, however,
a different annotator’s ? is better than nothing.
9 Conclusions
We have demonstrated a effective method for elic-
iting extra knowledge from naive annotators, in
the form of lightweight “rationales” for their an-
notations. By explicitly modeling the annotator’s
rationale-marking process, we are able to infer a bet-
ter model of the original annotations.
We showed that our method performs signifi-
cantly better than two strong baseline classifiers,
and also outperforms our previous discriminative
method for exploiting rationales (Zaidan et al.,
2007). We also saw that it worked across four anno-
tators who have different rationale-marking styles.
In future, we are interested in new domains that
can adaptively solicit rationales for some or all
training examples. Our new method, being essen-
tially Bayesian inference, is potentially extensible to
many other situations—other tasks, classifier archi-
tectures, and more complex features.
39
References
Eric Brill and Grace Ngai. 1999. Man [and woman] vs.
machine: A case study in base noun phrase learning.
In Proceedings of the 37th ACL Conference.
Michael Collins. 1999. Head-Driven Statistical Models
for Natural Language Parsing. Ph.D. thesis, Univer-
sity of Pennsylvania.
G. Druck, G. Mann, and A. McCallum. 2008. Learn-
ing from labeled features using generalized expecta-
tion criteria. In Proceedings of ACM Special Interest
Group on Information Retrieval, (SIGIR).
A. Haghighi and D. Klein. 2006. Prototype-driven learn-
ing for sequence models. In Proceedings of the Hu-
man Language Technology Conference of the NAACL,
Main Conference, pages 320–327, New York City,
USA, June. Association for Computational Linguis-
tics.
John Lafferty, Andrew McCallum, and Fernando Pereira.
2001. Conditional random fields: Probabilistic mod-
els for segmenting and labeling sequence data. In Pro-
ceedings of the International Conference on Machine
Learning.
Grace Ngai and David Yarowsky. 2000. Rule writing
or annotation: Cost-efficient resource usage for base
noun phrase chunking. In Proceedings of the 38th
Annual Meeting of the Association for Computational
Linguistics, pages 117–125, Hong Kong.
B. Pang and L. Lee. 2004. A sentimental education:
Sentiment analysis using subjectivity summarization
based on minimum cuts. In Proc. of ACL, pages 271–
278.
B. Pang, L. Lee, and S. Vaithyanathan. 2002. Thumbs
up? Sentiment classification using machine learning
techniques. In Proc. of EMNLP, pages 79–86.
Hema Raghavan and James Allan. 2007. An interactive
algorithm for asking and incorporating feature feed-
back into support vector machines. In Proceedings of
SIGIR.
Hema Raghavan, Omid Madani, and Rosie Jones. 2006.
Active learning on both features and instances. Jour-
nal of Machine Learning Research, 7:1655–1686,
Aug.
Luis von Ahn, Ruoran Liu, and Manuel Blum. 2006.
Peekaboom: A game for locating objects. In CHI
’06: Proceedings of the SIGCHI Conference on Hu-
man Factors in Computing Systems, pages 55–64.
Omar Zaidan, Jason Eisner, and Christine Piatko. 2007.
Using “annotator rationales” to improve machine
learning for text categorization. In NAACL HLT 2007;
Proceedings of the Main Conference, pages 260–267,
April.
40
