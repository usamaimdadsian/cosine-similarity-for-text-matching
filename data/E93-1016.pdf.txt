Parsing with polymorphism *
Mart in  Emms, 
The CIS 
Leopoldstr 139 
8000 Munchen 40 
Germany 
Abstract 
Certain phenomena resist coverage within 
the Lambek Calculus, such as scope- 
ambiguity and non-peripheral extraction. I 
have argued in previous work that an ex- 
tension called Polymorphic Lambek Calcu- 
lus (PLC), which adds variables and their 
universal quantification, covers these phe- 
nomena. However, a major problem is the 
absence of a known decision procedure for 
PLC grammars. This paper proposes a de- 
cision procedure which covers a subset of 
all the possible PLC grammars, a subset 
which, however, includes the PLC gram- 
mars with wide coverage. The decision pro- 
cedure is shown to be terminating, and cor- 
rect, and a Prolog implementation f it is 
described. 
1 The Lambek Calculus 
To begin, I give a brief description of Lambek cate- 
gorial grammar \[Lambek, 1958\]. The categories are 
built up from basic categories, using the binary cat- 
egorial connectives ' / '  and 'V. 1 Then a set of 'cat- 
egorial rules' involving these categories i defined, of 
the form: x l , . . . x ,  =~ y (n > 1), xi and y being cat- 
egories. A distinctive feature is that the set of rules 
is defined inductively. Using a term adopted from 
*This work was done whilst the author was in receipt 
of a six month scholarship from the German Academic 
Exchange Service, whose support is gratefully acknowl- 
edged 
1Lambek also considered a third connective, the 
'product'. I, in common with several authors, use the 
name Lambek calculus to refer to what is really the 
product-free calculus 
logic, sequent, in place of 'categorial rule', Lambek 
presented this inductive definition as a close variant 
of Gentzen's equent calculus for propositional logic. 
Lambek's calculus, L(/'\), is given below: 
(Ax) x =~ z 
(/L) U, y, V =~ w T ::~ z 
/L  
U,y/x,T,  V =~ w 
(\L) T =~ z U, y, Y =~ w 
\L 
U,T,y\~,  V ~ w 
(/R) T, z =~ y (\R) z, T =~ y 
T =~ y lz  T =~ y\z  
Here U, T, V are sequences of categories (U,V pos- 
sibly empty), w,z ,y  are categories. In the two 
premise rules, the T ::~ x premise is called the minor 
premise. The fact that L(//\)derives r, I will notate 
as L(/'\) ~-r. With regard to the names of the rules, 
'L' and 'R' stand for left and right. For example, 
( \ i )  (resp. (\R)), derives sequents with 'V on the 
left (resp. on the right) of the sequent arrow, ' =# '
For various purposes it is convenient to consider the 
addition of the 'Cut' rule, given below (in which z 
is referred to as the Cut formula, and T ::~ z as the 
minor premise): 
U,z ,V  =~ w T =~ z 
Cut 
U,T ,V~w 
Lambek \[1958\] establishes that n(/,\)+ Cut \]-r iff 
L(/,\)~-r (Cut elimination), and that L(/'\)~- r is de- 
cidable. 
120 
The proof of the decidability of L(/'\) }-- r proceeds 
as follows. First one reads the rules of L(/'\) 'back- 
wards', as a set of rewrites, growing a tree at its 
leaves 'up the page'. Call the trees grown this way 
deduction trees. L(/,\)~-r iff r is the root of a de- 
duction tree whose leaves are all axioms. I t  remains 
to note that there are only finitely many deduction 
trees for a given sequent: a leaf can be grown in 
at most a finite number of different ways, and the 
added daughters have always a diminished complex- 
ity (complexity measured as number of occurrences 
of connectives). This decision procedure is improved 
upon somewhat if the rules of the calculus are ex- 
pressed as a Prolog data base of conditionals concern- 
ing a binary predicate seq, holding between a list of 
categories and a single category. For later reference, 
let Lain stand for some such Prolog implementation 
of L(/'\). 
A grammar, G, in this perspective is an assignment 
of categories to words. Reading G }-s E y as 'accord- 
ing to G, s has category ', I will say G ~-s E y, if (i) 
s is lexically assigned y, or (ii) s = sl . . . so (n  > 1), 
G~-s~ E xi, and L ( / , \ )~-x l , . . . xn  =~ y. 
For any Lambek grammar, G, the question 
whether G~- s E x is decidable. This is got by 
combining Cut elimination with the decidability of 
L(/'\)~-r. Consider deciding whether G~sls2  E 
z, where 81 and s2 are lexically assigned the cat- 
egories x and y. One can first check whether 
L(\]'\)~-x,y:=~ z, which is decidable. If L(/,\)~ 
x, y :=~ z, then one should try a 'non-flat' categori- 
sation possibility. That is, one should also con- 
sider derivable categorisations of the subexpressions, 
namely x I and y' such that L(/,\)~- x =~ x', y ::~ y~, 
and check whether they may be combined to give 
z. Here lurks a problem, because there are infinitely 
many x ~ and y~ such that L(/,\)\[ - x :~ x I, y =V y~. 
The way out of this problem is the relationship be- 
tween the 'non-fiat' categorisation strategy and Cut- 
based proofs, to illustrate which, note that if there 
were derivable categorisations, x' and yl of the subex- 
pressions, which combined to give z, then L(/'\)+ Cut 
~x,  y :=~ z: 
(1) 
Y ==~ y, x I,yl ==~ z
Cut 
Cut 
x, y =C. z 
So parsing with an L(/,\) grammar comes to decid- 
ing the derivability of X l , . . . ,  xo =:~ s, where xi are 
the categories of the lexical items. 
This Lambek style of grammar is associated also 
with a certain method for assigning meanings to 
strings. The idea is that a proof, 7, of L(/'\)- can 
mapped into a semantic operation, ~. So, if there is 
a proof, 7, of Xl, . . . ,  ;go : :~ Y, then a sequence of 
expressions with categories X l , . . . ,  xn and meanings 
ml, . . - ,  ran, has a possible meaning 6(ma, . . . ,  too). 
As to which operation, G, goes with which proof, 7, 
this is defined by a term-associated calculus. Repre- 
sentative parts of the (extensionally) term associated 
calculus, L~/'\), are given below: 
(Ax) x : a =~ x : a 
(/L) U,y : a(  fl ), V =V w : e T =~ z : fl 
U,y/x : a ,T ,V  ~ w :e  
/L 
( /R )  T, x : ¢ :~ y : /R 
There are corresponding (\L) and (\R) rules. 
L~/'\)derives equents where in place of categories 
there are category:term pairs. If we start with an 
L(/,\) proof of r, and add variables to the antecedent 
categories of r, there is a unique way to add terms 
to the rest of the proof so as to get a proof of L (/'\). 
When this is done the term, a, associated with the 
succedent of r, represents the semantic operation. 
The above mentioned ecision procedure can be em- 
bellished to develop trees featuring semantic terms, 
some of them unknown, together with an evolving 
set of equations in these unknowns. When a proof is 
discovered, the term for that proof can be obtained 
by solving the set of equations. 
There is a semantic question to be asked about 
the acceptability of parsing simply by search through 
L(/,\) proofs: are all term-associated proofs for a 
sequent in L(/,\)+ Cut equivalent o some term- 
associated proof in L(/,\), and vice-versa ? The an- 
swer is yes \[Hendriks, 1989\], \[Moortgat, 1989\]. 
2 Po lymorph ism 
Despite the great simplicity of Lambek grammars, 
a surprising amount of coverage is possible \[Moort- 
gat, 1988\]. Two aspects of this are embryonic ac -. 
counts of extraction, and scope-ambiguity, the lat- 
ter arising from the fact that there may be more 
than one proof of a given sequent. However, the 
accounts possible have remained only partial. Non- 
peripheral extraction remainsd unaccounted for (eg. 
the (man)/ who Dave told ei to leave) and only the 
scope-ambiguities of peripheral quantifiers are cov- 
ered (as in the structure QNP TV QNP). A simple 
account of cross-categorial coordination has also of- 
ten been cited as an attractive feature of Lambek 
grammars (\[Moortgat, 1988\]). However, the analy- 
ses are never in a purely Lambek grammar. Belong- 
ing to Lambek grammar proper is a part assigning 
some category to the strings to be coordinated, and 
then lying without Lambek grammar, a coordination 
schema, such as x, and, x ::~ x. 
121 
To overcome these deficits in coverage, I have 
proposed a polymorphic extension of the calculus. 
Added to the categorial vocabulary are category 
variables and their universal quantification, allowing 
such categories as: X, X/X, VX.X/(X\np). To L(/,~ \~ 
are added left and right rules for V, to give what I will 
call L(/,\,v)(I given straightaway the term-associated 
calculus): 
(VL) U, x\[y/Z\] : c~(a), V :~ w: @ 
U, VZ.= : a, V =~ w : q~ 
(VR) T =V z : a \[Z is not free 
in 71 T =:~ VZ.z : Awa 
Notation: the terms are drawn from the language 
of 2nd Order Polymorphic A-calculus \[Girard, 1972\], 
\[Reynolds, 1974\]. Here, terms carry their type as 
a superscript, and one can have variables in these 
types (eg. Axr.x~), one can abstract over such vari- 
able types, deriving terms of quantified type (eg. 
A~r.Ax ~.z ~, of type Vr(Tr--*~r)), and terms of quanti- 
fied type can be applied to types (eg. Ar.Axr.=x(t), 
of type (Z-+Z)). In the (VL) rule above, the type, a, 
that a is applied to, is the type that corresponds to 
the category, y, that is being substituted for the cat- 
e~ory variable, Z. 2 An equivalent slight variant on 
L (/,\,v) takes as axioms only those z ::~ x sequents 
where z is basic or a variable, something I will call 
L~/'\'v). It is easy to show L~/'\'v)~-r iff L(/,\,v)~--r 
(see \[Emms and Leiss, forthcoming\]). 
By assigning conjunctions to YX.((X\X)/X), nega- 
tion to VX.X/X, and quantifiers to VX.X/(X\np) 
and VX.X\(X/np), one obtains coverage of cross- 
categorial coordination and negation, as well as a 
comprehensive account of quantifier scope ambiguity 
\[Emms, 1989\],\[Emms, 1991\]. Assigning relativisers 
to VX.((cn\cn)/(s\X)/(X/np)),  non-peripheral ex- 
traction can also be handled \[Emms, 1992\]. The 
meanings that go along with these categories are as 
follows. Where £ is Q, ff or A f, let/:G vary over the 
conventional meanings of quantifiers, junctions and 
negation, with £:p the polymorphic version. 
£p(t) = £G 
Q(a---*b)(pe'-"'~-"~)(x ") = Q(b)(y'---*Pyz) o) = 
who(a)(P~ a)(p~ t)(Qe t)(xe ) = P2(P~x) AQx 
I will give two illustrations. The proof below would 
allow the embedded quantifier, every man, to be as- 
signed a de-re interpretation i John believes every 
man walks. Note (s\np)\((s\np)/s)  : X. 
2The (VR) given is a cut-down version of the 'official' 
version, which allows a change of bound variable 
np, s\np ~ X 
nP, (s\np)/s, X =~s s\np =~.' '~npl: 
np, (s\np)/s, X/(X'\np) s\np ::~ s 
,¥L 
np, (s\np)/s, VX.X/(X\np), s\np ::~ s 
Now assuming j ,  bel, em and walk were the terms 
associated with the antecedents of the root sequent, 
the term for the proof is: 
emp (tel, et ) ( AxA f A y\[f (walk( z ) )( y) \] )( bel)(j ) 
We obtain as a possible denotation for John believes 
every man walks: 
emp(ta ,  a ) (=, / ,  y ~ f (wa lk (z ) ) (y ) ) (be l ) ( j )  
= emp(a) (~,  y ~ b~t(waZk(=))(y)) ( j )  
= emp(t)(z ~-* bel(walk(z))(j)) 
= emG(= 
As an illustration of non-peripheral extraction, the 
proof below allows the string who John told to go to 
be recognised as a postmodifier of a common oun: 
s/vpc, vpc =~ s 
__ \R 
r vpc =~ s\X 
D 
(c . \c . ) / (s \X) ,  vpc ca\ca 
np, V, np, vpc ::~ s 
/L _ ./L 
np, V :~ X/np 
/L 
rip, v, vpc cn\cn 
VL 
VX.((cn\cn)/(s\X)/(X/np)), rip, V, vpc cn\cn 
Here r = cn\cn ~ cn\cn, V -- ( (s\np)/vpc)/np,  
= s/vpc. Assuming who, j, told, and go were asso- 
ciated with the antecedents of the root, the term for 
the proof is: 
who( (et, t ) )( AzAy\[told(z)(y)(j)l)( A f \ [ f  (go)\]) 
We obtain for the denotation of the string who John 
told to go: 
who((et, t))(z, y ~ told(z)(y)(j))(f ~ /(go)) 
= Q, z ~ (( f  ~ f(go))((y ~ told(z)(v)(j))) A O(z)) 
= Q, z ~ (told(z)(go)(j) A Q(z)) 
For the further discussion of the analyses within 
an L (/,\,v) grammar that cover a significant range of 
data, see the earlier references. I turn now to the 
main problem which this paper addresses: is there 
an automatic procedure able to find these analyses ?
2.1 Cut  E l iminat ion  for  L (/,\,v) 
We want a procedure to decide whether G ~-s E z, 
where G is an L (/,\,v) grammar. As with L(/'\) gram- 
mars, this problem reduces to deciding L(/'\'v)~ - r if 
it can be shown both that Cut can be eliminated, 
and without the loss of any significant semantic di- 
versity. This has recently been shown (\[Emms and 
Leiss, forthcoming\]). I make some remarks on the 
proof. The strategy of the proof of Cut elimination 
for L (/A) starts from the observation that a proof, 7, 
122 
using Cut must contain at least one use of Cut which 
dominates no further uses of Cut - a ' topmost'  use 
of Cut. Suppose this use of Cut derives r. Then 
one defines two things: a degree of the Cut leading 
to r, and a transformation taking the proof of r to 
an alternative proof of r, such that either the trans- 
formed proof of r is Cut-free, or it is a proof with 
2 or less cuts of lesser degree. After a finite number 
of iterations of the transformation, one must have a 
cut free proof. 
In the proof for L (/'\), the degree of a Cut infer- 
ence is simply the sum of the numbers of connectives 
in the two premises. This cannot be the degree for 
L (/'\'v). For example, a cases to be considered is 
where one has a cut of the kind shown in (2). The 
natural rewrite is (3) (that T ~ y\[a/Z\] is provable 
relies on the fact that Z is not free in T and substi- 
tution for free variables preserves derivability \[Emms 
and Leiss, forthcoming\]) 
(2) T ~ v VR U, v\[~/Z\], V ~ WVL 
T ~ VZ.y U, VZ.v, V =~ w 
Cut 
V,T ,V  =~ w 
(3) T ::~ y\[a/Z\] U, y\[a/Z\], V =~. w 
.Cut 
U, T, V =C, w 
With degree defined by number of connectives, we 
need that the number of connectives in y\[a/Z\] is 
strictly less than the number in VZ.y, and that is 
often false. The proof goes through instead by tak- 
ing the degree of a cut to be the sum of sizes of the 
proofs of its two premises, where the size is the num- 
ber of nodes in the proof. 3 
2.2 Di f f icul t ies in dec id ing  L(/,\,v)}-T ::¢, x 
So the problem reduces to one of L (/'\'v) derivabil- 
ity. Whether L (/'\'v) derivability is decidable I do 
not know. The nearest to an answer to this that 
the logical literature comes is a result that quanti- 
fied intuitionistic propositional logic is undecidable 
\[Gabbay, 1974\]. The difference between L(/,\,v) and 
logic of this result is the presence of the further con- 
nectives (V, A), and the availability of all structural 
rules. I will describe below some of the problems that 
arise when some natural lines of thought towards a 
decision procedure are pursued. 
One might start by considering the logic that is 
L(/ ' \)+ (VR). This can be argued to be decidable 
in the same fashion as L(/'\): read (VR) backwards 
as a rewrite, adding another way to build deduction 
trees. As for L((/'\) a sequent has only finitely many 
deduction trees, and provability is equivalent o the 
existence of a deduction tree with axiom leaves. 
~In fact nodes above axiom form sequents are not  
counted in the size, and the proof relies on changes of 
bound variable and substitutions not changing the size 
of L(/'\'Y ) proofs 
However, when (VL) is added this simple argument 
will not work: if (VL) is read backwards as a further 
claus- ill tile definition of deduction trees, then a 
leaf containing an antecedent V could be rewritten 
infinitely many different ways. A natural move at. 
this point is to redefine deduction trees, reading the 
(VL) rule as an instruction to substitute all unknown. 
One hopes then that: (i) the set of so-defined educ- 
tion trees for a given sequent, r, is finite (ii) there is 
some easy to check property, P, of these trees such 
that the existence of a P-tree in the set would be 
equivalent to L(/,\,v)~-r. Now, if we were considering 
the combination of first-order quantification with the 
Lambek calculus, this strategy works, but whether it 
works for n (/'\,v) remains unknown. 
I will go through the application of the strategy in 
the first-order case to highlight why g(/,\,v) does not 
yield so easily. The first-order quantification plus the 
Lambek calculus, I will call L (/'\,v'). It is the end- 
point of a certain line of thought concerning agree- 
ment phenomena. One first reanalyses basic cate- 
gories, such as s and np, as being built up by the 
application of a predicate to some arguments, giving 
categories uch as np(3rd,sing), s(fin). It is natural 
then to consider quantification over the first order 
positions, such as Vp. s(fin)\np(p,pl), which could 
be used when, as in English, the plural forms of a 
verb are not distinguished according to person. Now 
L(/,\,v~) is decidable, which can be shown by adapt- 
ing an argument hat shows that when the contrac- 
tion rule is dropped from classical predicate logic, 
it becomes decidable \[Mey, 1992\]. Deduction trees 
for a sequent, r, of L (/'\'v~) are defined so that the 
rewrite associated with the (VL) rule substitutes an 
unknown. There are then only finitely many deduc- 
tion trees (the absence of the structural rule of con- 
traction is essential here). Now, if L(/'\'v')~--r, and r 
has a complex first order term, one can be sure that 
this term is present in an axiom, because no rules 
build complexity in the places in categories where a 
bound variable can occur. For this reason, the so- 
defined deduction trees for r cover all the possible 
patterns for a proof of r. Provability is therefore 
equivalent o the existence of a substitution making 
one of the deduction trees have axiom leaves, and 
this can be checked using resolution. 
This situation does not wholly carry over to 
g(/,\,v). The 'substitute an unknown' rewrite reading 
of (VL) defines only finitely many deduction trees for 
a sequent, r. However, these so-defined deduction 
trees for r do not cover all the possible palterns for 
a proof of r: unlike g (/,\'v~), there are rules that 
build complexity in the places in categories where a 
bound variable can occur. So, for example, L(/'\,v)~ - 
no, VX.X/(X\np), (s\np)\np,  but none of the de- 
duction trees represents the pattern of the proof. So 
to check for the existence of a deduction tree (as 
above defined) that by a substitution would have ax- 
123 
iom leaves is not sufficient o decide derivability. It 
seems we must defined the looked for property, P, 
of deduction trees recursively, so that a tree has P 
if (1) the leaves by a substitution become axioms, or 
(2) by hypothesising a connective in one of the un- 
knowns, and extending the tree by rewrites licensed 
by this connective, one obtains a P-tree. 
It would amount o the same thing if the definition 
of deduction tree was extended (by hypothesising a 
connective in an unknown), and the looked for prop- 
erty, P, kept simple: a tree whose leaves by a substi- 
tution become axioms. However, the extended def- 
inition of deduction tree now allows infinitely many 
trees for a sequent. This may seem surprising, but is 
seen one considers a leaf such as T ==~ X. One can hy- 
pothesis X = Y/Z, extend the deduction tree by the 
rewrite associated with a slash Right rule, obtain- 
ing once again a leaf with a succedent occurrence of 
an unknown. By imposing a control strategy which 
would systematically consider all deduction trees of 
height h, before deduction trees of height h + 1, one 
can be sure that any provable sequent would sooner 
or later be accepted by the decision procedure (be- 
cause its provability would entail the existence of a 
deduction tree of a certain finite height). However, 
there is no reason to expect the procedure to termi- 
nate when working on an underivable sequent. 4 
3 A par t ia l  dec is ion  procedure  fo r  
L(/,\,v) 
While there are problems in the way of a general de- 
cision procedure for L (/'\'V), I claim a partial decision 
procedure for L (/'\'v) is possible. Partial in the sense 
of covering only a certain class of sequents, but one 
sufficiently large, I claim, to cover all linguistically 
relevant cases. The procedure will be a partial deci- 
sion procedure for L (/,\,v) via being a partial decision 
procedure for L(0/'\'v). 
To describe the class of sequents that the proce- 
dure applies to I need definitions of the 'polarity' of 
an occurrence of a category. Let the category polarity 
of an occurrence of z in a category  (pol(z, y)) be: 
pol(x, z) = + 
if z occurs in y, pol(:~,y/z) 
pol(x, y) = opp(pol(x, z/y)) 
= pol(x,VZ.y) 
Here opp(+) = - ,  opp(-) = +. The sequent polarity 
of an occurrence of x in y in a sequent r is the same 
as the category polarity if y is an antecedent, and 
otherwise it is opposite. I use 'polarity' as short for 
'sequent polarity'. An example: 
(4) sk(V-X.X/(Xknp)) ::~ sk(V+X.X/(X\np)) 
4I have found non-terminating consecutively bounded 
depth first search to happen on the Prolog implementa- 
tion of the calculus that these paragraphs suggest 
The decision procedure to be described is applica- 
ble to sequents whose negative occurrences of poly- 
morphic categories are unlimited, but whose positive 
polymorphic ategories are drawn from: 
(5) VX.X/(X\np),  VX.X\(X/np),  
vx.x/x, 
VX.((cn\cn)/(s\X)/(X/np) 
vx.((x\x)/x), 
I will now make three observations concerning 
proofs in L (L\'v), leading up to the definition of the 
procedure. 
Observation One In the categories in (5) there is 
exactly one positive and one or two negative occur- 
rence of the bound variable. This leads to the pre- 
dictable occurrence of certain sequents. To help de- 
scribe these I need to define some more terminology. 
An initial labelling of a proof is the assignment of 
unique integers to some of the categories in some se- 
quent of the proof. A completed labelling is got from 
an initial labelling by a certain kind of propagation 
up the tree: a label is passed up when a labelled 
category is simply copied upward, and in a (VL) in- 
ference the label is distributed to the occurrences of 
the categories chosen for the variable. In other infer- 
ences where a labelled category is active, the label is 
not passed up. For example: 
(6) sl =~s s=~ sl np=~ np s=~s 
/L .\L 
sl/sl, s =~ s up, s\np =~ s 
VlX.X/X, s =~ s s\np =~ s\np 
vlx.x/x, s\np s 
I will say U, ai, V =~ w is 'positive for Vi' if the se- 
quent occurs in a labelled L (/'\ 'v) proof and the label 
on ai has been passed from a labelled occurrence of 
Vi. Correspondingly, call a sequent T ::~ ai 'negative 
for Vi'. Now note that in the above proof, the Vl in 
the root led to one V + and one V~" branch. This is 
no accident: one can predict the existence of such 
branches in any proof of a sequent with a positive 
occurrence of ViX.X/X. To see this, let me first de- 
fine a notion reflecting how 'embedded' a category 
is: 
path(a, a) = O. 
Where a occurs in x, path(a, x/y) - (/,path(a, x)), 
path(a,y/z) = (/,path(a,z)), path(a, VZ.x) = 
( v, path(a, z)) 
With the exception of bound variable, if a cate- 
gory occurs with a path (C,p), and a polarity 6, 
in the conclusion of an inference, then it occurs in 
the premises of that inference with the same po- 
larity, and with either the same path or with path 
p. Also, in leaves of a proof in L (/'\ 'v), categories 
only occur with zero path. Therefore, if we have 
124 
a proof of a sequent with a positive occurrence of 
ViX.X/X and with non-zero path, then there must 
occur higher in the proof, a sequent with V,.X.X/X 
occurring again positively and this time with with 
zero-path. In other words there must occur a node U, 
ViX.X/X, V =~ w. Then if there were no (VL) infer- 
ence in this proof introducing the category ViX.X/X, 
the category ViX.X/X would be present in the leaves 
of the proof. Because the leaves can only feature ha- 
sic categories, there must be a (VL) inference, and 
therefore a node U ~, ai/ai,  V ~ =~ w ~. Reasoning in a 
similar vein concerning the category ai/ai,  we can be 
sure there must be a (/L) inference, with premises 
U ~,a i ,V"=~w # and T ~=~al .  These are V + and 
V~- sequents. 
Provable sequents having a positive occurrence of 
one of the polymorphic ategories from (5), labelled 
with i, will generate an L~/'\'v) proof such that cor- 
responding to each of the positive and negative oc- 
currences of the bound variable, there are (distinct) 
V + and V~- branches. 
Observat ion Two We just argued that in any proof 
of a sequent with a positive occurrence of quantified 
category, there must occur a node at which the quan- 
tifier is introduced by a (VL) inference, and that for 
the categories in (5), V~ sequents must appear above 
this. For each of the V~ sequents, the minimum num- 
ber of steps there can be between the conclusion of 
the (VL) step and the V~ sequent is the length of 
the paths to the associated occurrence of the bound 
variable in the quantified category. Proofs featur- 
ing such minimum intervals between the quantified 
category and the associated V~ sequents I will call 
orderly. One can ask the question whether whenever 
there is a proof of a sequent whose positive quanti- 
tiers are drawn from the list in (5), there is also an 
(equivalent) orderly proof. And the answer is that 
there is. 
Proof sketch We want to show that for any cate- 
gory x in (5), for each of the occurrence of a variable 
in it, that if there is a proof of U, x, V =~ w, then 
there is a proof in which the steps leading from the 
lowest occurrence of the relevant V~ sequent o the 
(VL) inference correspond to the path to the bound 
variable in x. 
Let me define the spine of a category as: sp(x /y)  = 
(/, sp(x)), sp(VZ.x) = (V, sp(x)), sp(x) = O, where 
z is basic. 
We will show first for categories such that sp(x) = 
(V, slash), and sp(z)  = (slashl,  slash2), that when 
there is a proof such that the left inferences for the 
first two elements of the spine are separated by n 
steps there must be an equivalent proof where they 
are separated by n - 1 steps. 
One considers all the possibilities for the last in- 
tervening step, 1, and shows that the step associ- 
ated with the first element of the spine could have 
been done before l, thus lowering by 1 the number 
of steps intervening between the first two elements 
of the spine. There is not the space to show all the 
cases. (7), (S) and (9, (10) are representative exam- 
ples for sp(w) = (V, sp(x)).  Note that in (9) and (10) 
there are side-conditions to the (VR) inferences. Sat- 
isfaction of these for (9) entails satisfaction for (10). 
(11), (12) and (13),(14) show representative exam- 
ples for sp(w) = (slash1, slash2). In (14), X' is some 
variable chosen to be not free in U, x /y /z ,  T, V and 
w. The provability of the upper premise U, x /y ,  V 
w\ [X ' /X \ ]  follows from that of U, z /y ,  V ~ w by 
substitution for the variable X throughout. 5 As to 
the equivalence of the proofs, one can confirm that in 
the term-associated versions, the same term is paired 
with the succedent category in each case. 
(7) U, a, V2 =~ w x'/y', V1 =*, b 
/L 
U, a/b, x' /y ' ,  Va, V~ =~ w 
"¥L 
U, a/b, VZ.x/y, V1, V2 :=~w 
(8) E/v', v~ =~ b 
.VL 
U , a , V2 =~ w V Z. x / y , V1 =~ b 
"/L 
U, a/b, VZ.x/y, V1, V2 =~ w 
(9) U, x'/y', V ~ z 
VR 
U, z'/y', V :0 VY.z 
.VL 
U, YX.z/y,  V ~ VY.z 
(10) U, s'/y', V =~ z 
-¥L 
U, VX.z/y, V =~ z 
VR 
U, VX.z/y, V =~ VY.z 
(11) U, a, V =~ w x/y,  T2 =~ b 
.\]L 
U, a/b, x/y,  T2, V ~ w T1 :* z 
/L 
U, a/b, x /y /z ,  T1, T2, V =~ w 
(12) z/y ,  T2 ~ b T1 =~ z 
/L 
U, a, V m, w x/V/z,  T1, T2 ~ b 
/L 
U, a/b, x /y /z ,  T1, T~, V =*, w 
(13) U, x/y, V ~ w 
VR 
V, x/y, Y ~ VYw\[Y /X\ ]  T =~ z 
./i 
U, z /y /z ,  T, V ~ VYw\[Y/X\ ]  
U, z /y ,  Y =~ w\ [X ' /Z \ ]  T =~ z 
./L 
U, x /y /z ,  T, V ~ w\[X ' lX \ ]  
'VR 
U, x /y /z ,  T, V ~ VYw\[Y /X\ ]  
(14) 
5Here the 'full' version of (VR) is being used, incorpo- 
rating a change of bound variable. See earlier footnote. 
125 
This is enough to show orderly proofs for 
VX.X/X and VX.(X\X)/X. For VX.X/(X\np) and 
VX.((cn\cn)/(s\X)/(X/np)) we must further show 
that if there is a proof of T =~ x /y  whose last step is 
not a (/R) inference introducing x/y,  then there is 
an equivalent proof whose last step is a (JR) infer- 
ence introducing ~./y. One can show this by showing 
if there is a proof whose last two steps use (/R) fol- 
lowed by some rule *, then there is an equivalent 
proof reversing that order. (15) and (16) illustrate 
this. 
(15) U, a, V, y ~ x 
/R 
U,a ,V  ~x/y  T~b 
/n 
U, a/b, T, V ~ z/y 
(16) U, a, V, y =~ x T =~ b 
/L 
U, a, T, V, y ~ 
U, a/b, T, V =~ x/y/R 
So much by way of a sketch of a proof. I will 
put the fact that orderly proofs exist to the follow- 
ing use. For sequents whose positive quantifiers are 
drawn from the list in (5), one can be sure that if they 
have proofs at all, they have a proofs which instan- 
tiate quantifiers 'one at a time'. One at time in the 
sense that once a there is a (VL) inference, one can 
suppose there will be no more (VL) on the branches 
leading to the first occurrences of a V~ sequents. 
Observat ion  Three  Bearing in mind Observation 
One, the question whether a given choice, hi, for the 
value of the quantified variable is a good one will 
come to depend, sooner or later, on the derivability, 
of a certain set of V/6 sequents, containing one V~ 
sequent and one or two V~- sequents. In relation to 
this consider the following: 
Fact 1 (Unknown e l iminat ion)  (i) and (ii) are 
equivalent 
(i) There is an x such that L(/,\,v)\[-U,x,V ~ w, 
Ti ~ z . . . .  , T, ~ z 
(it) L(/'\'v)~-U, Ti, V =¢, w, . . . ,  U, T, ,  V =:~ w 
The proof of this, from left to right uses 
Cut and Cut-Elimination. For example, from 
L(/,\,v)~-U, x, V =¢. w, L(/,\,v)~-Ti =¢, x, we deduce 
L(/'\'V)+ Cut ~-U, Ti, V ~ w. Therefore by Cut 
elimination, L(I,\,v)~U, T1, V ~ w. For the right 
to left direction, let me say that (w\U) /V  is a 
shorthand for (w\ui  . . . \us )  /v,, . . . / v i .  We 
choose the x to be (w\U) /Y .  Clearly for 
this x, L(I,\,v)~-U,x,V ~ w. Also each of the 
claims L(/,\,v)~-T/ =~ x, follows from the assumed 
U, 7~,V~w,  simply by sufficiently many slash 
Right inferences. 
On the basis of these observations, I suggest he 
following decision procedure: 6
Def in i t ion  1 (Dec is ion  procedure)  Where A, r 
vary over possibly empty sequences of sequents, let a 
rewrite procedure 7~ be defined as follows 
1. A, z =t, x, r .,~ A, r ,  where x is atomic 
2. A, T :=~ w, r .,., A,  O, r ,  if T "=~ w follows 
from 0 by some rule of L(/'\'v) other than O/L) 
3. A, U, VZ.z, V =~ w, r ~ A, z\[x/Z\],  V =~ w, r,  
where X is an unknown, and there are no other 
unknowns in A,  U, VZ.z, V ::~ w, r 
4. A, U,X,V =~ w, Tx =~ X . . . .  , T,  ~X,  r 
..~ A U, T1, V =¢, w, . . . ,  U, Tn, V ~ w, r 
A sequent T ~ w is accepted iff the sequence con- 
sisting of just this sequence can be rewritten to the 
empty sequence by 7¢. 
The fourth clause slightly oversimplifies what I in- 
tend in the two respects that (i) the rewrite can apply 
when the U, X, V =¢, w, T1 =¢, X, . . . ,  T,  =¢, X occur 
dispersed in any order through the sequence, and (it) 
it can only apply if the unknown X does not occur in 
sequents other than those mentioned. Note because 
of clause 3, there will only ever be one unknown in 
the state of the procedure. This corresponds to Ob- 
servation Two above. I will show that this procedure 
is terminating and correct when applied to sequents 
whose positive quantifiers are drawn from (5). By 
correctness of the procedure, I mean that the pro- 
cedure accepts r i f f  L(/,\,V)\]--r. The implication left 
to right I will call soundness, and from right to left 
completeness. 
There is a term associated version of this deci- 
sion procedure, rewriting a pair consisting of a set 
of equations, and a sequence of term-associated se- 
quents. On the basis of the discussion earlier, for 
the most part the the reader should be able to eas- 
ily imagine what embellishments are required to the 
clauses of the rewrite. I will just give the full version 
of the Clause 4 rewrite. The input will be: 
Equations:E 
Sequence: A, U : ~7,_. X:@I, V : ~' =t, w : @2, Ti : t~ 
:~ X:~l, . . . ,  Tn : tn ::~ X:q/n, r 
The output will be: 
Equations:E plus ¢2 = (\]~I(~-~)(U), I I /1 - -  )tV~'tA~tI#i, 
. . . ,  ~ ,  = ~u~"  
Sequence: A, U : ~ ,  T1: 4 ,  V : ~ =~ w : @\], . . . ,  
U :un,  Tn :~,V :~ =¢, w : ~ ,  r 
3.1 Terminat ion  
If there are any rewrites possible for a sequence there 
at most finitely many. So we require that no rewrite 
series can be infinitely long. Call the sequents fea- 
turing an unknown a linked set. At any one time 
nSince writing this paper, I have discovered that the 
above observation concerning unknown elimination have 
been made before \[Moortgat, 1988\], \[Benthem, 1990\]. 
This will be further discussed at the end of the paper 
126 
there is at most one linked set. Let the degree, d, of 
a sequence be the total number of connectives. All 
rewrites on a sequence that has no linked set lower 
the degree. So rewriting can only go on finitely long 
before it stops or a linked set is introduced. A linked 
set is introduced by a clause 3 rewrite, introducing 
an unknown into some particular sequent. Call this 
the input sequent. While the sequence contains a 
linked set, either the degree of the whole sequence 
goes down, and the sequence remains one containing 
a linked set (clause 1, clause 2), or the sequence be- 
comes one no longer containing a linked set (clause 
4). So a rewrite can only go on finitely long before 
it either stops, or has a phase where a linked set 
is introduced and then eliminated. Call the sequents 
which result from the elimination of the unknown in a 
clause 4 rewrite, the oulpul sequents. Now consider- 
ing any such phase of unknown introduction followed 
by elimination, one can say that the count of posi- 
tive quantifiers in the input sequent must be strictly 
greater than the count of positive quantifiers in any 
of the outputs. This, taken together with the fact 
that the maximum count of positive quantifiers is 
never increased outside of such phases, means that 
there can only by finitely many such phases in a 
rewrite. 
3.2 Soundness  
We show that if the procedure accepts a sequence 
of n sequents (n > 1), then there is substitution for 
the unknowns such that there are n proofs of the n 
substituted for sequents. This subsumes oundness, 
which is where n = 1 and there are no unknowns. I
shall use sub(A) to refer to the sequence of sequents 
got from A by some substitution for the unknowns in 
A, and L(/,\,v)~-A for the claim that there are proofs 
of each of the sequents in A 
The proof is by induction on the length of the 
shortest accepting rewrite. When the shortest ac- 
cepting rewrite is of length 1, the sequence must con- 
sist simply of an axiom, and so there is a proof. Now 
suppose the statement is true for all sequences whose 
shortest accepting rewrite is less than 1. Then for se- 
quences whose shortest accepting rewrite is of length 
l, we consider case-wise what the first rewrite might 
be. 
 clause 2 rewrite, for example: A, U, z/y, T, V ~ w, 
F .,.* A, U,x, V =~. w, T ::~ y, F. A, U,x, V ~ w, 
T ::~ y, r must have a shortest accepting rewrite 
of length < l, so by induction there is a substitu- 
tion such that L(/,\,v)~-sub(A), sub(U,x,V =~ w), 
sub(T ::V y), sub(r). From this it follows that 
L(/,\,V)Fsub(A), sub(U,z/y,T, V ~ ~), sub(r). 
The other possibilities for clause 2 rewrites work in 
a similar way 
 clause 3 rewrite: A, U, VZ.x,V=~w, F 
~.~ A, U,x\[X/Z\], V =~ w, A. By induction 
there is a substitution such that L(l'\'v)~-sub(A), 
sub(U,.x\[X/Z\], Y ::V w, sub(A). Let sub' be the sub- 
stitution that differs from sub simply by substitut- 
ing nothing for X. sub'(VZ.x) -- VZ(sub'(x)), and 
sub(x\[X/Z\]) = subt(x)\[sub(X)/Z\]. It follows that 
L(/,\,v)~-sub'(~), sub'(U, VZ.~, V ~ ~), sub'(F) 
* clause 4 rewrite. A, U ,X,V: :~w,  T1 ::~X, . . . ,  
Tn ~ X, r ..~ A U, T1, V =v w, . . . ,  U, Tn, V =V w 
r .  By induction: L(/,\,v)~-sub(A), 
sub(U, T1, V =~ w,... ,  U, T,, V : ,  w), sub(r). Let 
sub' be the substitution that differs from sub sim- 
ply by substituting for X, sub(w\U/V). Clearly 
L(/,\,v)~ - sub'(U,X,V=~w). Also for each T~, 
it follows from L(/,\,v)~-sub(U, Ti, V :=0 w) that 
L(/,\'v)~-sub'(Ti =~ X). Hence L(/,\,v)~-subl(A), 
sub'(U, X, V =~ w), sub'(T1 =~ X), . . . ,  sub'(T, ::~ X), 
sub'(r) \[\] 
3.3 Completeness  
I will now show completeness for sequents whose pos- 
itive polymorphic ategories are drawn from (5). 
By a frontier, f ,  in a proof, I will mean either the 
leaves of that proof or the leaves of a subtree having 
the same root. Given a frontier f in a proof p, which 
has some completed labelling, the procedure will be 
said to be in a state s that corresponds to f ,  if the 
state and the frontier are identical except that (i) s 
may have some axioms deleted as compared with f ,  
and (ii) the occurrences of labelled, non-quantified 
ai in f ,  are transformed to occurrences of some un- 
known in s. Given a state s, I will say that a frontier, 
f ,  is accessible if there is a state corresponding to f 
that the procedure may reach from s. 
I assume the procedure is complete for unknown- 
free sequents whose positive quantifier count is zero. 7 
Now suppose the procedure is complete for unknown- 
free sequents whose positive quantifier count is less 
than some particular n, and consider a sequent r, of 
positive quantifier count n, with some proof, p, and 
one of the form remarked upon in Observation Two. 
There will be (VL) inferences in this proof, amongst 
which is a set lower than any others. Take the con- 
clusion of one such (VL) inference, U, VX.y, V ==~ w 
and from all other branches pick a point not above a 
(VL) inference. This set of points forms a frontier, f ,  
which is accessible if the procedure starts at r. Call 
the corresponding state s. The sequents in the state 
other than U, VX.y, V =~z w are unknown-free, have 
a positive quantifier count of less than n, and have 
a proof, and so by induction the procedure is com- 
plete for them. So there is a possible later state s I 
which consists olely of the sequent U, VX.y, V ~ w. 
We now focus on the subproof of p that is rooted in 
U, VX.y, V =~ w. Consider VX.y as labelled with i, 
and labelling to have been propagated up the tree. I 
want to define a certain accessible frontier, if, in this 
tree. There are a certain finite number of branches 
ending in U, VX.y, V ::~ w. A certain subset of those 
7I am of course assuming that all these positive quan- 
tified categories are drawn from the list in (5) 
127 
branches lead to V~ sequents, and without any in- 
tervening (VL) inferences. Select for the frontier f '  
tile lowest occurrences for the V~ sequents. From 
the other branches imply select a set of nodes, P, 
which is not preceded by a (VL). This frontier is ac- 
cessible, and the corresponding state is: U, Xi, V 
=2,, w, T1 z=~ Xi, . . . ,  Tn ~ Xi. By a clause 4 rewrite 
this leads to: U, T1, V =~ w, . . . ,  U, T,, V ~ w. This 
state is unknown free, each of the sequents has pos- 
itive quantifier count less than n, and each has a 
proof. So by induction, the procedure is complete for 
each of the sequents, and the state may be rewritten 
to O" \[\] 
4 Implementat ion  
We can with respect o the term-associated version 
of the decision procedure ask whether it is semanti. 
cally comprehensive: whether the procedure assigns, 
up to logical equivalence, xactly the same terms to 
a sequent as are assigned to it by the declarative defi- 
nition of an L(/,\'v) grammar. Some but not all parts 
of what is necessary for a proof of this are established 
- that Cut elimination for L (/'\'v) preserves readings, 
that restriction to orderly proofs loses no readings. 
However, for the moment, he claim rests ultimately 
on empirical evidence, drawn from the prolog imple- 
mentation that I will now describe. I will describe 
the implementation as additions/alterations to the 
earlier mentioned Laln. 
First, it was noted in Observation Two, that one can 
insist in proof search that Slash right rules are used 
as soon as their application become possible: this 
early use of Slash right rules is the first modification 
of Lain. For the sake of the discussion, assume it is 
done by adding to non Slash right rules a check on 
the absence of a slash in the succedent. 
Second, a conditional for (VL) is added: 
seq(\[U,pol(X,Y):Terral,V\],W:Terra2):- 
groundseqC\[U,pol(X,Y):Tez~l,V\], 
W:Term2), 
substituteCXl,X,Y,Yl), ~ Y1 is Y\[XI/X\] 
mark(Y1,Y2), 
seq(\[U,Y2:Terml(Ty),V\],W:Term2) , 
cattotype(X1,Ty). 
Note, polymorphic categories appear as terms uch 
as pol (x ,x/x) .  The code is in a simplified form, 
pretending that \[U, X, V\] matches any list that is the 
appending together of the lists U, fX\] and V, where in 
reality there are further clauses taking care of this. 
The conditional basically substitutes an unknown for 
a quantified variable. Prior to the substitution there 
is a check, groundseq, that the categories in the goal 
do not already feature some syntactic unknown. Sub- 
sequent o substitution, the mark relation leads to 
the replacement of the positive occurrence of the un- 
known Xl with (Xl,a). 
Third, a goal featuring a zero-path occurrence of 
(Xl, a) :Term matches no standard sequent rule, be- 
cause of the marking, matching instead an 'argument 
stacking' conditional: 
seqC\[U:\[~,CX,a) :F,V:~ ~\] ,W:Tena) :- 
x = (w\u) /v ,  Tez~ = FC~)Cr~) 
Fourth, sequents featuring the marked version of the 
unknown are dealt with before sequents featuring the 
unmarked (negative) instances of the unknown, by 
ordering the major premise before the minor in the 
conditionals for the Slash Left rules. 
To illustrate I will 'trace' the behaviour of the pro- 
gram on the goal given as 1 below (tv stands for 
(s\np)/np 
1. seq( \ [np : f , tv :g ,po lCx ,x \ (x /np) ) :h \ ] , s :T )  
2. seq( \ [np : f , tv :g , (X i ,a ) \ (X l /np) :h (Ty) \ ] ,  
s:T) 
3. seq( \ [np: f , (X l ,a) :h(Ty)(T1) \ ] ,s :T)  
4. Xl = sknp, T : h(Ty)(T1)(f) 
5. seq(\ [ (s \np)/np:g\]  ,s\np/np:T1) 
6. TI = )~x ~y g(x)(y) 
7. cattotype(s\np,Ty)  
8. Ty = (e,t) 
9. T = h(Ce , t ) ) ( Ix  ~y gxy)( f )  
1 matches against he (VL) clause. The check that 
there are no syntactic unknowns around is success- 
ful, and after substitution and marking, we reach the 
subgoal shown as 2, which introduces the new un- 
knowns Xl and Ty. 2 matches against the (\L) clause, 
the first subgoal of which is the major premise, shown 
as 3, with the new unknown T1 (if we could pick 
the minor premise, we would have non-termination). 
3 matches only the 'argument s acking' conditional, 
giving a solution for Xl and solving T in terms of Ty 
and T1, as shown in 4. The second subgoal of 2 is 
then considered, under the current bindings, which 
is 5. 5 will solve via a combination of slash Left and 
slash Right rules, giving the solution for T1 shown in 
6. 2 is now satisfied, and the final subgoal of 1 is 
considered under the current bindings, which is 7. 7 
solves with the solution for Ty shown in 8. 1 is now 
satisfied, and the solution for T is shown in 9 (recall 
in 4, T was expressed in terms of Ty and T1). 
Space precludes giving a formal argument that this 
Prolog implementation a d the foregoing decision 
procedure correspond, in the sense that they suc- 
ceed and fail on the same sequents, and assign the 
same terms. By way of indication of the behaviour 
of the implementation, and in particular its seman- 
tic comprehensiveness, I give below some examples 
of what the implementation does by way of assigning 
readings. In all but the last two cases the task is to 
reduce to s. For the last two it is to reduce to cn. 
128 
(17) a. every man walks (I) 
b. every man loves a woman (2) 
C. John believes Mary thinks every man walks 
(3) 
d. every man a woman 2 flowers (0) 
e. every man loves a woman 2 flowers (0) 
f. every man gave a woman 2 flowers (6) 
g. (omdat) John gek en Mary dom is (1) 
h. man who John told to go (1) 
i. man who John told Mary to go (0) 
5 Conc lud ing  remarks  
To pick up on an earlier footnote, I have discovered 
since writing this paper that Benthem and Moort- 
gat have shown decidable, by using what I have re- 
ferred to as Unknown Elimination, the system which 
is L(/'\) with an added rule of 'Boolean Cut': 
U,x,V ~ w TI ~ x T2 ~ x 
-Bool.Cut 
U, T1,J,T2,V =~ w 
The question arises then of the relation between 
their work and what has been proposed in this paper. 
At the very least, I hope to have shown that there is 
lurking in this Unknown Elimination technique, an 
approach not only to coordination, but also to quan- 
tifier scope ambiguity and non-peripheral extraction. 
The main difference between the decision procedure 
for L (/'\'v) and that for L(/,\)+ Bool.Cut is that the 
Unknown Elimination technique isput to work on se- 
quents which do not arise from special purpose Cut 
rules, but simply by the elimination of categorial con- 
nectives from certainkinds of categories containing 
unknowns. This introduces ome intricacies into the 
proof of completeness, which the observation con- 
cerning orderly proofs was used to deal with. 
As to the scope of the decision procedure, this 
ought to have a more general specification than that 
which has been given here, though I have not yet 
found it. A plausible seeming idea is that there 
should be one positive and several negative occur- 
rences of a bound variable. However, this includes a 
category such as VX.s/(X/X), and a proof featuring 
this category is not guaranteed to produce separate 
V ~ sequents. 
A direction for future research would be to in- 
vestigate the possibility of combining this approach 
to quantification, coordination and extraction with 
non-categorial ccounts of other aspects of a lan- 
guage. The idea would be to use such a non- 
categorial grammar as an extended axiom base. If 
this turned out to be feasible then we would have an 
attractively portable account of quantification, coor- 
dination and extraction. 
Re ferences  
\[Benthem, 1990\] Johan van Benthem. Categorial 
Grammar meets unification. In Unification for- 
malisms: syntax, semantics and implementation, 
J.Wedekind et al.(eds.). 
\[Emms, 1989\] Martin Emms. Polymorphic Quanti- 
tiers. In Proceedings of the Seventh Amsterdam 
Colloquium, pages 139-163, Torenvliet, M. S. L. 
(ed.), Institute for Language, Logic and Informa- 
tion, Amsterdam, December 1989. 
\[Emms, 1991\] Martin Emms. Polymorphic Quanti- 
tiers. In Studies in Categoriai Grammar Barry, G. 
and Morrill, G. (eds.) , pages 65-112, Volume 5 of 
Working Papers in Cognitive Science, 1991, Edin- 
burgh, Centre for Cognitive Science. 
\[Emms, 1992\] Martin Emms. Logical Ambiguity. 
PhD Thesis, Centre of Cognitive Science, Edin- 
burgh. 
\[Emms and Leiss, forthcoming\] Martin Emms and 
Hans Leiss. Cut Elimination for Polymorphic 
Lambek Calculus. CIS Technical Report, forth- 
coming. 
\[Gabbay, 1974\] Dov Gabbay. Semantical Investiga- 
tions in Heyting's Intuitionistic Logic Dordrecht: 
Reidel. 
\[Girard, 1972\] :I. Y. Girard. Interpreta- 
tion Fonctionelle t Elimination des Coupres de 
L'Arithmetique d'Order Superieur. PhD Thesis. 
\[Hendriks, 1989\] Herman Hendriks. Cut Elimination 
and Semantics in Lambek Calculus Manuscript 
available from University of Amsterdam. To ap- 
pear in his PhD thesis 'Studied Flexibility'. 
\[Lambek, 1958\] Joachim Lambek. The mathemat- 
ics of sentence structure. American Mathematical 
Monthly, 65:154-170, 1958. 
\[Mey, 1992\] Daniel Mey. Investigations on a Calcu- 
lus Without Contractions. PhD Thesis, Swiss Fed- 
eral Institute of Technology, Zurich. 
\[Moortgat, 1988\] Michael Moortgat. Categorial In- 
vestigations: Logical and Linguistic Aspects of the 
Lambek Calculus. Dordrecht: Forts Publications. 
\[Moortgat, 1989\] Michael Moortgat. Unambiguous 
proof representations for the Lambek Calculus. 
In Proceedings of the Seventh Amsterdam Collo- 
quium, pages 389-401, Torenvliet, M. S. L. (ed.), 
Institute for Language, Logic and Information, 
Amsterdam, December 1989. 
\[Reynolds, 1974\] :I.C Reynolds. Towards a theory of 
type structure. In Colloquium sur la programma- 
tion, 1974, pages 408-423. 
129 
