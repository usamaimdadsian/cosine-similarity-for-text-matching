Making Tree Kernels practical for Natural Language Learning
Alessandro Moschitti
Department of Computer Science
University of Rome ”Tor Vergata”
Rome, Italy
moschitti@info.uniroma2.it
Abstract
In recent years tree kernels have been pro-
posed for the automatic learning of natural
language applications. Unfortunately, they
show (a) an inherent super linear complex-
ity and (b) a lower accuracy than tradi-
tional attribute/value methods.
In this paper, we show that tree kernels
are very helpful in the processing of nat-
ural language as (a) we provide a simple
algorithm to compute tree kernels in linear
average running time and (b) our study on
the classification properties of diverse tree
kernels show that kernel combinations al-
ways improve the traditional methods. Ex-
periments with Support Vector Machines
on the predicate argument classification
task provide empirical support to our the-
sis.
1 Introduction
In recent years tree kernels have been shown to
be interesting approaches for the modeling of syn-
tactic information in natural language tasks, e.g.
syntactic parsing (Collins and Duffy, 2002), rela-
tion extraction (Zelenko et al., 2003), Named En-
tity recognition (Cumby and Roth, 2003; Culotta
and Sorensen, 2004) and Semantic Parsing (Mos-
chitti, 2004).
The main tree kernel advantage is the possibility
to generate a high number of syntactic features and
let the learning algorithm to select those most rel-
evant for a specific application. In contrast, their
major drawback are (a) the computational time
complexity which is superlinear in the number of
tree nodes and (b) the accuracy that they produce is
often lower than the one provided by linear models
on manually designed features.
To solve problem (a), a linear complexity al-
gorithm for the subtree (ST) kernel computation,
was designed in (Vishwanathan and Smola, 2002).
Unfortunately, the ST set is rather poorer than the
one generated by the subset tree (SST) kernel de-
signed in (Collins and Duffy, 2002). Intuitively,
an ST rooted in a node n of the target tree always
contains all n’s descendants until the leaves. This
does not hold for the SSTs whose leaves can be
internal nodes.
To solve the problem (b), a study on different
tree substructure spaces should be carried out to
derive the tree kernel that provide the highest ac-
curacy. On the one hand, SSTs provide learn-
ing algorithms with richer information which may
be critical to capture syntactic properties of parse
trees as shown, for example, in (Zelenko et al.,
2003; Moschitti, 2004). On the other hand, if the
SST space contains too many irrelevant features,
overfitting may occur and decrease the classifica-
tion accuracy (Cumby and Roth, 2003). As a con-
sequence, the fewer features of the ST approach
may be more appropriate.
In this paper, we aim to solve the above prob-
lems. We present (a) an algorithm for the eval-
uation of the ST and SST kernels which runs in
linear average time and (b) a study of the impact
of diverse tree kernels on the accuracy of Support
Vector Machines (SVMs).
Our fast algorithm computes the kernels be-
tween two syntactic parse trees in O(m + n) av-
erage time, where m and n are the number of
nodes in the two trees. This low complexity al-
lows SVMs to carry out experiments on hundreds
of thousands of training instances since it is not
higher than the complexity of the polynomial ker-
113
nel, widely used on large experimentation e.g.
(Pradhan et al., 2004). To confirm such hypothe-
sis, we measured the impact of the algorithm on
the time required by SVMs for the learning of
about 122,774 predicate argument examples anno-
tated in PropBank (Kingsbury and Palmer, 2002)
and 37,948 instances annotated in FrameNet (Fill-
more, 1982).
Regarding the classification properties, we stud-
ied the argument labeling accuracy of ST and SST
kernels and their combinations with the standard
features (Gildea and Jurafsky, 2002). The re-
sults show that, on both PropBank and FrameNet
datasets, the SST-based kernel, i.e. the richest
in terms of substructures, produces the highest
SVM accuracy. When SSTs are combined with the
manual designed features, we always obtain the
best figure classifier. This suggests that the many
fragments included in the SST space are relevant
and, since their manual design may be problem-
atic (requiring a higher programming effort and
deeper knowledge of the linguistic phenomenon),
tree kernels provide a remarkable help in feature
engineering.
In the remainder of this paper, Section 2 de-
scribes the parse tree kernels and our fast algo-
rithm. Section 3 introduces the predicate argument
classification problem and its solution. Section 4
shows the comparative performance in term of the
execution time and accuracy. Finally, Section 5
discusses the related work whereas Section 6 sum-
marizes the conclusions.
2 Fast Parse Tree Kernels
The kernels that we consider represent trees in
terms of their substructures (fragments). These
latter define feature spaces which, in turn, are
mapped into vector spaces, e.g. <n. The asso-
ciated kernel function measures the similarity be-
tween two trees by counting the number of their
common fragments. More precisely, a kernel func-
tion detects if a tree subpart (common to both
trees) belongs to the feature space that we intend
to generate. For such purpose, the fragment types
need to be described. We consider two important
characterizations: the subtrees (STs) and the sub-
set trees (SSTs).
2.1 Subtrees and Subset Trees
In our study, we consider syntactic parse trees,
consequently, each node with its children is asso-
ciated with a grammar production rule, where the
symbol at left-hand side corresponds to the parent
node and the symbols at right-hand side are asso-
ciated with its children. The terminal symbols of
the grammar are always associated with the leaves
of the tree. For example, Figure 1 illustrates the
syntactic parse of the sentence "Mary brought a
cat to school".
S ? N VP
VP ? V NP PP
PP ? IN N
N ? school
N
school
The root
A leaf 
S
N
NP
D N
VP
VMary
to
brought 
a cat
PP
IN
A subtree
Figure 1: A syntactic parse tree.
We define as a subtree (ST) any node of a tree
along with all its descendants. For example, the
line in Figure 1 circles the subtree rooted in the NP
node. A subset tree (SST) is a more general struc-
ture. The difference with the subtrees is that the
leaves can be associated with non-terminal sym-
bols. The SSTs satisfy the constraint that they are
generated by applying the same grammatical rule
set which generated the original tree. For exam-
ple, [S [N VP]] is a SST of the tree in Figure
1 which has two non-terminal symbols, N and VP,
as leaves.
S
N
NP
D N
VP
VMary
brought
a
   cat
NP
D N
a
   cat
N
   cat
D
a
V
brought 
N
Mary
NP
D N
VP
V
brought 
a
   cat
Figure 2: A syntactic parse tree with its subtrees (STs).
NP
D N
a
  cat
NP
D N
NP
D N
a
NP
D N
NP
D N
VP
V
brought
a
   cat
  cat
NP
D N
VP
V
a
   cat
NP
D N
VP
V
N
   cat
D
a
V
brought 
N
Mary
…
Figure 3: A tree with some of its subset trees (SSTs).
Given a syntactic tree we can use as feature rep-
resentation the set of all its STs or SSTs. For ex-
ample, Figure 2 shows the parse tree of the sen-
tence "Mary brought a cat" together with its 6
STs, whereas Figure 3 shows 10 SSTs (out of
17) of the subtree of Figure 2 rooted in VP. The
114
high different number of substructures gives an in-
tuitive quantification of the different information
level between the two tree-based representations.
2.2 The Tree Kernel Functions
The main idea of tree kernels is to compute the
number of the common substructures between two
trees T1 and T2 without explicitly considering
the whole fragment space. For this purpose, we
slightly modified the kernel function proposed in
(Collins and Duffy, 2002) by introducing a param-
eter ? which enables the ST or the SST evaluation.
Given the set of fragments {f1, f2, ..} = F , we
defined the indicator function Ii(n) which is equal
1 if the target fi is rooted at node n and 0 other-
wise. We define
K(T1, T2) =
?
n1?NT1
?
n2?NT2
?(n1, n2) (1)
where NT1 and NT2 are the sets of the T1’s
and T2’s nodes, respectively and ?(n1, n2) =
?|F|
i=1 Ii(n1)Ii(n2). This latter is equal to the
number of common fragments rooted in the n1 and
n2 nodes. We can compute ? as follows:
1. if the productions at n1 and n2 are different
then ?(n1, n2) = 0;
2. if the productions at n1 and n2 are the
same, and n1 and n2 have only leaf children
(i.e. they are pre-terminals symbols) then
?(n1, n2) = 1;
3. if the productions at n1 and n2 are the same,
and n1 and n2 are not pre-terminals then
?(n1, n2) =
nc(n1)
?
j=1
(? + ?(cjn1 , c
j
n2)) (2)
where ? ? {0, 1}, nc(n1) is the number of the
children of n1 and cjn is the j-th child of the node
n. Note that, since the productions are the same,
nc(n1) = nc(n2).
When ? = 0, ?(n1, n2) is equal 1 only if
?j ?(cjn1 , cjn2) = 1, i.e. all the productions as-
sociated with the children are identical. By recur-
sively applying this property, it follows that the
subtrees in n1 and n2 are identical. Thus, Eq. 1
evaluates the subtree (ST) kernel. When ? = 1,
?(n1, n2) evaluates the number of SSTs common
to n1 and n2 as proved in (Collins and Duffy,
2002).
Additionally, we study some variations of the
above kernels which include the leaves in the frag-
ment space. For this purpose, it is enough to add
the condition:
0. if n1 and n2 are leaves and their associated
symbols are equal then ?(n1, n2) = 1,
to the recursive rule set for the ? evaluation
(Zhang and Lee, 2003). We will refer to such ex-
tended kernels as ST+bow and SST+bow (bag-of-
words).
Moreover, we add the decay factor ? by modi-
fying steps (2) and (3) as follows1:
2. ?(n1, n2) = ?,
3. ?(n1, n2) = ?
?nc(n1)
j=1 (? + ?(cjn1 , cjn2)).
The computational complexity of Eq. 1 is
O(|NT1 | × |NT2 |). We will refer to this basic im-
plementation as the Quadratic Tree Kernel (QTK).
However, as observed in (Collins and Duffy, 2002)
this worst case is quite unlikely for the syntactic
trees of natural language sentences, thus, we can
design algorithms that run in linear time on aver-
age.
function Evaluate Pair Set(Tree T1, T2) returns NODE PAIR SET;
LIST L1,L2;
NODE PAIR SET Np;
begin
L1 = T1.ordered list;
L2 = T2.ordered list; /*the lists were sorted at loading time*/
n1 = extract(L1); /*get the head element and*/
n2 = extract(L2); /*remove it from the list*/
while (n1 and n2 are not NULL)
if (production of(n1) > production of(n2))
then n2 = extract(L2);
else if (production of(n1) < production of(n2))
then n1 = extract(L1);
else
while (production of(n1) == production of(n2))
while (production of(n1) == production of(n2))
add(?n1, n2?, Np);
n2=get next elem(L2); /*get the head element
and move the pointer to the next element*/
end
n1 = extract(L1);
reset(L2); /*set the pointer at the first element*/
end
end
return Np ;
end
Table 1: Pseudo-code for fast evaluation of the node pair
sets used in the fast Tree Kernel.
2.3 A Fast Tree Kernel (FTK)
To compute the kernels defined in the previous
section, we sum the ? function for each pair
?n1, n2?? NT1 × NT2 (Eq. 1). When the pro-
ductions associated with n1 and n2 are different,
we can avoid to evaluate ?(n1, n2) since it is 0.
1To have a similarity score between 0 and 1, we also ap-
ply the normalization in the kernel space, i.e. K?(T1, T2) =
K(T1,T2)?
K(T1,T1)×K(T2,T2)
.
115
SN
NP
D N
VP
VMary
  to
brought 
a cat
PP
IN N
school
Arg. 0
Arg. MArg. 1
Predicate 
NP
D N
VP
V
brought 
a cat
SArg1 VP
V
  to
brought 
PP
IN N
school
S
N
VMary
brought 
VP
SArg0 SArgM
Figure 4: Tree substructure space for predicate argument classification.
Thus, we look for a node pair set Np ={?n1, n2??
NT1 × NT2 : p(n1) = p(n2)}, where p(n) returns
the production rule associated with n.
To efficiently build Np, we (i) extract the L1 and
L2 lists of the production rules from T1 and T2,
(ii) sort them in the alphanumeric order and (iii)
scan them to find the node pairs ?n1, n2? such that
(p(n1) = p(n2)) ? L1?L2. Step (iii) may require
only O(|NT1 | + |NT2 |) time, but, if p(n1) appears
r1 times in T1 and p(n2) is repeated r2 times in
T2, we need to consider r1 × r2 pairs. The formal
algorithm is given in Table 1.
Note that:
(a) The list sorting can be done only once at the
data preparation time (i.e. before training) in
O(|NT1 | × log(|NT1 |)).
(b) The algorithm shows that the worst case oc-
curs when the parse trees are both generated us-
ing only one production rule, i.e. the two inter-
nal while cycles carry out |NT1 |×|NT2 | iterations.
In contrast, two identical parse trees may generate
a linear number of non-null pairs if there are few
groups of nodes associated with the same produc-
tion rule.
(c) Such approach is perfectly compatible with the
dynamic programming algorithm which computes
?. In fact, the only difference with the original
approach is that the matrix entries corresponding
to pairs of different production rules are not con-
sidered. Since such entries contain null values
they do not affect the application of the original
dynamic programming. Moreover, the order of
the pair evaluation can be established at run time,
starting from the root nodes towards the children.
3 A Semantic Application of Parse Tree
Kernels
An interesting application of the SST kernel is
the classification of the predicate argument struc-
tures defined in PropBank (Kingsbury and Palmer,
2002) or FrameNet (Fillmore, 1982). Figure
4 shows the parse tree of the sentence: "Mary
brought a cat to school" along with the pred-
icate argument annotation proposed in the Prop-
Bank project. Only verbs are considered as pred-
icates whereas arguments are labeled sequentially
from ARG0 to ARG9.
Also in FrameNet predicate/argument informa-
tion is described but for this purpose richer seman-
tic structures called Frames are used. The Frames
are schematic representations of situations involv-
ing various participants, properties and roles in
which a word may be typically used. Frame el-
ements or semantic roles are arguments of pred-
icates called target words. For example the fol-
lowing sentence is annotated according to the AR-
REST frame:
[Time One Saturday night] [ Authorities police
in Brooklyn ] [Target apprehended ] [ Suspect
sixteen teenagers].
The roles Suspect and Authorities are specific to
the frame.
The common approach to learn the classifica-
tion of predicate arguments relates to the extrac-
tion of features from the syntactic parse tree of
the target sentence. In (Gildea and Jurafsky, 2002)
seven different features2, which aim to capture the
relation between the predicate and its arguments,
were proposed. For example, the Parse Tree Path
of the pair ?brought, ARG1? in the syntactic tree
of Figure 4 is V ? VP ? NP. It encodes the depen-
dency between the predicate and the argument as a
sequence of nonterminal labels linked by direction
symbols (up or down).
An alternative tree kernel representation, pro-
posed in (Moschitti, 2004), is the selection of the
minimal tree subset that includes a predicate with
only one of its arguments. For example, in Figure
4, the substructures inside the three frames are the
semantic/syntactic structures associated with the
three arguments of the verb to bring, i.e. SARG0,
SARG1 and SARGM .
Given a feature representation of predicate ar-
2Namely, they are Phrase Type, Parse Tree Path, Pred-
icate Word, Head Word, Governing Category, Position and
Voice.
116
guments, we can build an individual ONE-vs-ALL
(OVA) classifier Ci for each argument i. As a fi-
nal decision of the multiclassifier, we select the ar-
gument type ARGt associated with the maximum
value among the scores provided by the Ci, i.e.
t = argmaxi?S score(Ci), where S is the set
of argument types. We adopted the OVA approach
as it is simple and effective as showed in (Pradhan
et al., 2004).
Note that the representation in Figure 4 is quite
intuitive and, to conceive it, the designer requires
much less linguistic knowledge about semantic
roles than those necessary to define relevant fea-
tures manually. To understand such point, we
should make a step back before Gildea and Juraf-
sky defined the first set of features for Semantic
Role Labeling (SRL). The idea that syntax may
have been useful to derive semantic information
was already inspired by linguists, but from a ma-
chine learning point of view, to decide which tree
fragments may have been useful for semantic role
labeling was not an easy task. In principle, the de-
signer should have had to select and experiment
all possible tree subparts. This is exactly what the
tree kernels can automatically do: the designer just
need to roughly select the interesting whole sub-
tree (correlated with the linguistic phenomenon)
and the tree kernel will generate all possible syn-
tactic features from it. The task of selecting the
most relevant substructures is carried out by the
kernel machines themselves.
4 The Experiments
The aim of the experiments is twofold. On the one
hand, we show that the FTK running time is linear
on the average case and is much faster than QTK.
This is accomplished by measuring the learning
time and the average kernel computation time. On
the other hand, we study the impact of the differ-
ent tree based kernels on the predicate argument
classification accuracy.
4.1 Experimental Set-up
We used two different corpora: PropBank
(www.cis.upenn.edu/?ace) along with Pen-
nTree bank 2 (Marcus et al., 1993) and FrameNet.
PropBank contains about 53,700 sentences and
a fixed split between training and testing which has
been used in other researches, e.g. (Gildea and
Palmer, 2002; Pradhan et al., 2004). In this split,
sections from 02 to 21 are used for training, sec-
tion 23 for testing and sections 1 and 22 as devel-
oping set. We considered a total of 122,774 and
7,359 arguments (from ARG0 to ARG9, ARGA
and ARGM) in training and testing, respectively.
Their tree structures were extracted from the Penn
Treebank. It should be noted that the main contri-
bution to the global accuracy is given by ARG0,
ARG1 and ARGM.
From the FrameNet corpus (http://www.icsi
.berkeley.edu/?framenet), we extracted all
24,558 sentences of the 40 Frames selected for
the Automatic Labeling of Semantic Roles task of
Senseval 3 (www.senseval.org). We mapped to-
gether the semantic roles having the same name
and we considered only the 18 most frequent roles
associated with verbal predicates, for a total of
37,948 arguments. We randomly selected 30% of
sentences for testing and 70% for training. Addi-
tionally, 30% of training was used as a validation-
set. Note that, since the FrameNet data does not
include deep syntactic tree annotation, we pro-
cessed the FrameNet data with Collins’ parser
(Collins, 1997), consequently, the experiments on
FrameNet relate to automatic syntactic parse trees.
The classifier evaluations were carried out
with the SVM-light-TK software available at
http://ai-nlp.info.uniroma2.it/moschitti/
which encodes ST and SST kernels in the SVM-
light software (Joachims, 1999). We used the
default linear (Linear) and polynomial (Poly)
kernels for the evaluations with the standard
features defined in (Gildea and Jurafsky, 2002).
We adopted the default regularization parameter
(i.e., the average of 1/||~x||) and we tried a few
cost-factor values (i.e., j ? {1, 3, 7, 10, 30, 100})
to adjust the rate between Precision and Recall on
the validation-set.
For the ST and SST kernels, we derived that the
best ? (see Section 2.2) were 1 and 0.4, respec-
tively. The classification performance was eval-
uated using the F1 measure3 for the single argu-
ments and the accuracy for the final multiclassi-
fier. This latter choice allows us to compare our
results with previous literature work, e.g. (Gildea
and Jurafsky, 2002; Pradhan et al., 2004).
4.2 Time Complexity Experiments
In this section we compare our Fast Tree Kernel
(FTK) approach with the Quadratic Tree Kernel
(QTK) algorithm. The latter refers to the naive
evaluation of Eq. 1 as presented in (Collins and
Duffy, 2002).
3F1 assigns equal importance to Precision P and Recall
R, i.e. f1 = 2P×RP+R .
117
Figure 5 shows the learning time4 of the SVMs
using QTK and FTK (over the SST structures)
for the classification of one large argument (i.e.
ARG0), according to different percentages of
training data. We note that, with 70% of the train-
ing data, FTK is about 10 times faster than QTK.
With all the training data FTK terminated in 6
hours whereas QTK required more than 1 week.
y = 0.0006x 2  - 0.001x
y = 0.0045x 2  + 0.1004x
0
5
10
15
20
25
30
35
0 10 20 30 40 50 60 70 80 90 100
% Training Data
H
o
u
rs
FTK
QTK
Figure 5: ARG0 classifier learning time according to dif-
ferent training percentages.
y = 0.04x 2  - 0.05x
y = 0.14x
0
20
40
60
80
100
120
10 15 20 25 30 35 40 45 50 55 60
Number of Tree Nodes
µµ µµs
ec
o
n
ds
FTK
QTK
Figure 6: Average time in seconds for the QTK and FTK
evaluations.
0.76
0.78
0.80
0.82
0.84
0.86
0.88
0.90
0 10 20 30 40 50 60 70 80 90 100
% Training Data
A
c
c
u
ra
c
y
ST
SST
ST+bow
SST+bow
Linear
Poly
Figure 7: Multiclassifier accuracy according to different
training set percentages.
4We run the experiments on a Pentium 4, 2GHz, with 1
Gb ram.
The above results are quite interesting because
they show that (1) we can use tree kernels with
SVMs on huge training sets, e.g. on 122,774 in-
stances and (2) the time needed to converge is ap-
proximately the one required by SVMs when us-
ing polynomial kernel. This latter shows the mini-
mal complexity needed to work in the dual space.
To study the FTK running time, we extracted
from PennTree bank the first 500 trees5 containing
exactly n nodes, then, we evaluated all 25,000 pos-
sible tree pairs. Each point of the Figure 6 shows
the average computation time on all the tree pairs
of a fixed size n.
In the figures, the trend lines which best inter-
polates the experimental values are also shown. It
clearly appears that the training time is quadratic
as SVMs have quadratic learning time complexity
(see Figure 5) whereas the FTK running time has
a linear behavior (Figure 6). The QTK algorithm
shows a quadratic running time complexity, as ex-
pected.
4.3 Accuracy of the Tree Kernels
In these experiments, we investigate which ker-
nel is the most accurate for the predicate argument
classification.
First, we run ST, SST, ST+bow, SST+bow, Lin-
ear and Poly kernels over different training-set size
of PropBank. Figure 7 shows the learning curves
associated with the above kernels for the SVM-
based multiclassifier. We note that (a) SSTs have
a higher accuracy than STs, (b) bow does not im-
prove either ST or SST kernels and (c) in the fi-
nal part of the plot SST shows a higher gradient
than ST, Linear and Poly. This latter produces
the best accuracy 90.5% in line with the litera-
ture findings using standard features and polyno-
mial SVMs, e.g. 87.1%6 in (Pradhan et al., 2004).
Second, in tables 2 and 3, we report the results
using all available training data, on PropBank and
FrameNet test sets, respectively. Each row of the
two tables shows the F1 measure of the individ-
ual classifiers using different kernels whereas the
last column illustrates the global accuracy of the
multiclassifier.
5We measured also the computation time for the incom-
plete trees associated with the predicate argument structures
(see Section 3); we obtained the same results.
6The small difference (2.4%) is mainly due to the differ-
ent treatment of ARGMs: we built a single ARGM class for
all subclasses, e.g. ARGM-LOC and ARGM-TMP, whereas
in (Pradhan et al., 2004), the ARGMs, were evaluated sepa-
rately.
118
We note that, the F1 of the single arguments
across the different kernels follows the same be-
havior of the global multiclassifier accuracy. On
FrameNet, the bow impact on the ST and SST
accuracy is higher than on PropBank as it pro-
duces an improvement of about 1.5%. This sug-
gests that (1) to detect semantic roles, lexical in-
formation is very important, (2) bow give a higher
contribution as errors in POS-tagging make the
word + POS fragments less reliable and (3) as the
FrameNet trees are obtained with the Collins’ syn-
tactic parser, tree kernels seem robust to incorrect
parse trees.
Third, we point out that the polynomial ker-
nel on flat features is more accurate than tree ker-
nels but the design of such effective features re-
quired noticeable knowledge and effort (Gildea
and Jurafsky, 2002). On the contrary, the choice
of subtrees suitable to syntactically characterize a
target phenomenon seems a easier task (see Sec-
tion 3 for the predicate argument case). More-
over, by combining polynomial and SST kernels,
we can improve the classification accuracy (Mos-
chitti, 2004), i.e. tree kernels provide the learn-
ing algorithm with many relevant fragments which
hardly can be designed by hand. In fact, as many
predicate argument structures are quite large (up
to 100 nodes) they contain many fragments.
ARGs ST SST ST+bow SST+bow Linear Poly
ARG0 86.5 88.0 86.9 88.4 88.6 90.6
ARG1 83.1 87.4 82.8 86.7 85.9 90.8
ARG2 58.0 67.6 58.9 66.7 65.5 80.4
ARG3 35.7 37.5 39.3 41.2 51.9 60.4
ARG4 62.7 65.6 63.3 63.9 66.2 70.0
ARGM 92.0 94.2 92.0 93.7 94.9 95.3
Acc. 84.6 87.7 84.8 87.5 87.6 90.7
Table 2: Evaluation of Kernels on PropBank.
Roles ST SST ST+bow SST+bow Linear Poly
agent 86.9 87.8 89.2 90.2 89.8 91.7
theme 76.1 79.2 78.5 80.7 82.9 90.4
goal 77.9 78.9 78.2 80.1 80.2 85.8
path 82.8 84.4 83.7 85.1 81.3 85.5
manner 79.9 82.0 81.3 82.5 70.8 80.5
source 85.6 87.7 86.9 87.8 86.5 89.8
time 76.3 78.3 77.0 79.1 61.8 68.3
reason 75.9 77.3 78.9 81.4 82.9 86.4
Acc. 80.0 81.2 81.3 82.9 82.3 85.6
18 roles
Table 3: Evaluation of the Kernels on FrameNet semantic
roles.
Finally, to study the combined kernels, we ap-
plied the K1 + ?K2 formula, where K1 is either
the Linear or the Poly kernel and K2 is the ST
Corpus Poly ST+Linear SST+Linear ST+Poly SST+Poly
PropBank 90.7 88.6 89.4 91.1 91.3
FrameNet 85.6 85.3 85.8 87.5 87.2
Table 4: Multiclassifier accuracy using Kernel Combina-
tions.
or the SST kernel. Table 4 shows the results of
four kernel combinations. We note that, (a) STs
and SSTs improve Poly (about 0.5 and 2 percent
points on PropBank and FrameNet, respectively)
and (b) the linear kernel, which uses fewer fea-
tures than Poly, is more enhanced by the SSTs than
STs (for example on PropBank we have 89.4% and
88.6% vs. 87.6%), i.e. Linear takes advantage by
the richer feature set of the SSTs. It should be
noted that our results of kernel combinations on
FrameNet are in contrast with (Moschitti, 2004),
where no improvement was obtained. Our expla-
nation is that, thanks to the fast evaluation of FTK,
we could carry out an adequate parameterization.
5 Related Work
Recently, several tree kernels have been designed.
In the following, we highlight their differences and
properties.
In (Collins and Duffy, 2002), the SST tree ker-
nel was experimented with the Voted Perceptron
for the parse-tree reranking task. The combination
with the original PCFG model improved the syn-
tactic parsing. Additionally, it was alluded that the
average execution time depends on the number of
repeated productions.
In (Vishwanathan and Smola, 2002), a linear
complexity algorithm for the computation of the
ST kernel is provided (in the worst case). The
main idea is the use of the suffix trees to store par-
tial matches for the evaluation of the string kernel
(Lodhi et al., 2000). This can be used to compute
the ST fragments once the tree is converted into a
string. To our knowledge, ours is the first applica-
tion of the ST kernel for a natural language task.
In (Kazama and Torisawa, 2005), an interesting
algorithm that speeds up the average running time
is presented. Such algorithm looks for node pairs
that have in common a large number of trees (ma-
licious nodes) and applies a transformation to the
trees rooted in such nodes to make faster the kernel
computation. The results show an increase of the
speed similar to the one produced by our method.
In (Zelenko et al., 2003), two kernels over syn-
tactic shallow parser structures were devised for
the extraction of linguistic relations, e.g. person-
affiliation. To measure the similarity between two
119
nodes, the contiguous string kernel and the sparse
string kernel (Lodhi et al., 2000) were used. In
(Culotta and Sorensen, 2004) such kernels were
slightly generalized by providing a matching func-
tion for the node pairs. The time complexity for
their computation limited the experiments on data
set of just 200 news items. Moreover, we note that
the above tree kernels are not convolution kernels
as those proposed in this article.
In (Shen et al., 2003), a tree-kernel based on
Lexicalized Tree Adjoining Grammar (LTAG) for
the parse-reranking task was proposed. Since
QTK was used for the kernel computation, the
high learning complexity forced the authors to
train different SVMs on different slices of train-
ing data. Our FTK, adapted for the LTAG tree ker-
nel, would have allowed SVMs to be trained on
the whole data.
In (Cumby and Roth, 2003), a feature descrip-
tion language was used to extract structural fea-
tures from the syntactic shallow parse trees asso-
ciated with named entities. The experiments on
the named entity categorization showed that when
the description language selects an adequate set of
tree fragments the Voted Perceptron algorithm in-
creases its classification accuracy. The explana-
tion was that the complete tree fragment set con-
tains many irrelevant features and may cause over-
fitting.
6 Conclusions
In this paper, we have shown that tree kernels
can effectively be adopted in practical natural lan-
guage applications. The main arguments against
their use are their efficiency and accuracy lower
than traditional feature based approaches. We
have shown that a fast algorithm (FTK) can evalu-
ate tree kernels in a linear average running time
and also that the overall converging time re-
quired by SVMs is compatible with very large
data sets. Regarding the accuracy, the experiments
with Support Vector Machines on the PropBank
and FrameNet predicate argument structures show
that: (a) the richer the kernel is in term of substruc-
tures (e.g. SST), the higher the accuracy is, (b)
tree kernels are effective also in case of automatic
parse trees and (c) as kernel combinations always
improve traditional feature models, the best ap-
proach is to combine scalar-based and structured
based kernels.
Acknowledgments
I would like to thank the AI group at the University of Rome
”Tor Vergata”. Many thanks to the EACL 2006 anonymous
reviewers, Roberto Basili and Giorgio Satta who provided
me with valuable suggestions. This research is partially sup-
ported by the Presto Space EU Project#: FP6-507336.
References
Michael Collins and Nigel Duffy. 2002. New ranking al-
gorithms for parsing and tagging: Kernels over discrete
structures, and the voted perceptron. In ACL02.
Michael Collins. 1997. Three generative, lexicalized mod-
els for statistical parsing. In proceedings of the ACL97,
Madrid, Spain.
Aron Culotta and Jeffrey Sorensen. 2004. Dependency tree
kernels for relation extraction. In proceedings of ACL04,
Barcelona, Spain.
Chad Cumby and Dan Roth. 2003. Kernel methods for rela-
tional learning. In proceedings of ICML 2003. Washing-
ton, US.
Charles J. Fillmore. 1982. Frame semantics. In Linguistics
in the Morning Calm.
Daniel Gildea and Daniel Jurafsky. 2002. Automatic
labeling of semantic roles. Computational Linguistic,
28(3):496–530.
Daniel Gildea and Martha Palmer. 2002. The necessity of
parsing for predicate argument recognition. In proceed-
ings of ACL02, Philadelphia, PA.
T. Joachims. 1999. Making large-scale SVM learning prac-
tical. In B. Scho¨lkopf, C. Burges, and A. Smola, editors,
Advances in Kernel Methods - Support Vector Learning.
Junichi Kazama and Kentaro Torisawa. 2005. Speeding up
training with tree kernels for node relation labeling. In
proceedings of EMNLP 2005, Toronto, Canada.
Paul Kingsbury and Martha Palmer. 2002. From Treebank to
PropBank. In proceedings of LREC-2002, Spain.
Huma Lodhi, Craig Saunders, John Shawe-Taylor, Nello
Cristianini, and Christopher Watkins. 2000. Text clas-
sification using string kernels. In NIPS02, Vancouver,
Canada.
M. P. Marcus, B. Santorini, and M. A. Marcinkiewicz. 1993.
Building a large annotated corpus of english: The Penn
Treebank. Computational Linguistics, 19:313–330.
Alessandro Moschitti. 2004. A study on convolution ker-
nels for shallow semantic parsing. In proceedings ACL04,
Barcelona, Spain.
Sameer Pradhan, Kadri Hacioglu, Valeri Krugler, Wayne
Ward, James H. Martin, and Daniel Jurafsky. 2005. Sup-
port vector learning for semantic argument classification.
Machine Learning Journal.
Libin Shen, Anoop Sarkar, and Aravind Joshi. 2003. Using
LTAG based features in parse reranking. In proceedings
of EMNLP 2003, Sapporo, Japan.
Ben Taskar, Dan Klein, Mike Collins, Daphne Koller, and
Christopher Manning. 2004. Max-margin parsing. In
proceedings of EMNLP 2004 Barcelona, Spain.
S.V.N. Vishwanathan and A.J. Smola. 2002. Fast kernels on
strings and trees. In proceedings of Neural Information
Processing Systems.
D. Zelenko, C. Aone, and A. Richardella. 2003. Ker-
nel methods for relation extraction. Journal of Machine
Learning Research.
Dell Zhang and Wee Sun Lee. 2003. Question classifica-
tion using support vector machines. In proceedings of SI-
GIR’03, ACM Press.
120
